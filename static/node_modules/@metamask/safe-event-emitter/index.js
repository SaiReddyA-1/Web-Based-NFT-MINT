"use strict";

var _classCallCheck = require("C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/classCallCheck");

var _createClass = require("C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/createClass");

var _inherits = require("C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/inherits");

var _possibleConstructorReturn = require("C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/possibleConstructorReturn");

var _getPrototypeOf = require("C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/getPrototypeOf");

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

Object.defineProperty(exports, "__esModule", {
  value: true
});

var events_1 = require("events");

function safeApply(handler, context, args) {
  try {
    Reflect.apply(handler, context, args);
  } catch (err) {
    // Throw error after timeout so as not to interrupt the stack
    setTimeout(function () {
      throw err;
    });
  }
}

function arrayClone(arr) {
  var n = arr.length;
  var copy = new Array(n);

  for (var i = 0; i < n; i += 1) {
    copy[i] = arr[i];
  }

  return copy;
}

var SafeEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(SafeEventEmitter, _events_1$EventEmitte);

  var _super = _createSuper(SafeEventEmitter);

  function SafeEventEmitter() {
    _classCallCheck(this, SafeEventEmitter);

    return _super.apply(this, arguments);
  }

  _createClass(SafeEventEmitter, [{
    key: "emit",
    value: function emit(type) {
      var doError = type === 'error';
      var events = this._events;

      if (events !== undefined) {
        doError = doError && events.error === undefined;
      } else if (!doError) {
        return false;
      } // If there is no 'error' event listener then throw.


      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      if (doError) {
        var er;

        if (args.length > 0) {
          er = args[0];
        }

        if (er instanceof Error) {
          // Note: The comments on the `throw` lines are intentional, they show
          // up in Node's output if this results in an unhandled exception.
          throw er; // Unhandled 'error' event
        } // At least give some kind of context to the user


        var err = new Error("Unhandled error.".concat(er ? " (".concat(er.message, ")") : ''));
        err.context = er;
        throw err; // Unhandled 'error' event
      }

      var handler = events[type];

      if (handler === undefined) {
        return false;
      }

      if (typeof handler === 'function') {
        safeApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler);

        for (var i = 0; i < len; i += 1) {
          safeApply(listeners[i], this, args);
        }
      }

      return true;
    }
  }]);

  return SafeEventEmitter;
}(events_1.EventEmitter);

exports.default = SafeEventEmitter;