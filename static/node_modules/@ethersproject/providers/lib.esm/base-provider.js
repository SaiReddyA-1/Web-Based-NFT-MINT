"use strict";

import _assertThisInitialized from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/assertThisInitialized";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";
import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";
import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { ForkEvent, Provider } from "@ethersproject/abstract-provider";
import { Base58 } from "@ethersproject/basex";
import { BigNumber } from "@ethersproject/bignumber";
import { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from "@ethersproject/bytes";
import { HashZero } from "@ethersproject/constants";
import { dnsEncode, namehash } from "@ethersproject/hash";
import { getNetwork as _getNetwork } from "@ethersproject/networks";
import { defineReadOnly, getStatic, resolveProperties } from "@ethersproject/properties";
import { sha256 } from "@ethersproject/sha2";
import { toUtf8Bytes, toUtf8String } from "@ethersproject/strings";
import { fetchJson, poll } from "@ethersproject/web";
import bech32 from "bech32";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);
import { Formatter } from "./formatter";
var MAX_CCIP_REDIRECTS = 10; //////////////////////////////
// Event Serializeing

function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }

  if (hexDataLength(topic) !== 32) {
    logger.throwArgumentError("invalid topic", "topic", topic);
  }

  return topic.toLowerCase();
}

function serializeTopics(topics) {
  // Remove trailing null AND-topics; they are redundant
  topics = topics.slice();

  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }

  return topics.map(function (topic) {
    if (Array.isArray(topic)) {
      // Only track unique OR-topics
      var unique = {};
      topic.forEach(function (topic) {
        unique[checkTopic(topic)] = true;
      }); // The order of OR-topics does not matter

      var sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}

function deserializeTopics(data) {
  if (data === "") {
    return [];
  }

  return data.split(/&/g).map(function (topic) {
    if (topic === "") {
      return [];
    }

    var comps = topic.split("|").map(function (topic) {
      return topic === "null" ? null : topic;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}

function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();

    if (hexDataLength(eventName) === 32) {
      return "tx:" + eventName;
    }

    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (ForkEvent.isForkEvent(eventName)) {
    logger.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }

  throw new Error("invalid event - " + eventName);
} //////////////////////////////
// Helper Object


function getTime() {
  return new Date().getTime();
}

function stall(duration) {
  return new Promise(function (resolve) {
    setTimeout(resolve, duration);
  });
} //////////////////////////////
// Provider Object

/**
 *  EventType
 *   - "block"
 *   - "poll"
 *   - "didPoll"
 *   - "pending"
 *   - "error"
 *   - "network"
 *   - filter
 *   - topics array
 *   - transaction hash
 */


var PollableEvents = ["block", "network", "pending", "poll"];
export var Event = /*#__PURE__*/function () {
  function Event(tag, listener, once) {
    _classCallCheck(this, Event);

    defineReadOnly(this, "tag", tag);
    defineReadOnly(this, "listener", listener);
    defineReadOnly(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }

  _createClass(Event, [{
    key: "event",
    get: function get() {
      switch (this.type) {
        case "tx":
          return this.hash;

        case "filter":
          return this.filter;
      }

      return this.tag;
    }
  }, {
    key: "type",
    get: function get() {
      return this.tag.split(":")[0];
    }
  }, {
    key: "hash",
    get: function get() {
      var comps = this.tag.split(":");

      if (comps[0] !== "tx") {
        return null;
      }

      return comps[1];
    }
  }, {
    key: "filter",
    get: function get() {
      var comps = this.tag.split(":");

      if (comps[0] !== "filter") {
        return null;
      }

      var address = comps[1];
      var topics = deserializeTopics(comps[2]);
      var filter = {};

      if (topics.length > 0) {
        filter.topics = topics;
      }

      if (address && address !== "*") {
        filter.address = address;
      }

      return filter;
    }
  }, {
    key: "pollable",
    value: function pollable() {
      return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
    }
  }]);

  return Event;
}();
; // https://github.com/satoshilabs/slips/blob/master/slip-0044.md

var coinInfos = {
  "0": {
    symbol: "btc",
    p2pkh: 0x00,
    p2sh: 0x05,
    prefix: "bc"
  },
  "2": {
    symbol: "ltc",
    p2pkh: 0x30,
    p2sh: 0x32,
    prefix: "ltc"
  },
  "3": {
    symbol: "doge",
    p2pkh: 0x1e,
    p2sh: 0x16
  },
  "60": {
    symbol: "eth",
    ilk: "eth"
  },
  "61": {
    symbol: "etc",
    ilk: "eth"
  },
  "700": {
    symbol: "xdai",
    ilk: "eth"
  }
};

function bytes32ify(value) {
  return hexZeroPad(BigNumber.from(value).toHexString(), 32);
} // Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)


function base58Encode(data) {
  return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));
}

var matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
var matchers = [new RegExp("^(https):/\/(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), matcherIpfs, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];

function _parseString(result, start) {
  try {
    return toUtf8String(_parseBytes(result, start));
  } catch (error) {}

  return null;
}

function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }

  var offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();
  var length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();
  return hexDataSlice(result, offset + 32, offset + 32 + length);
} // Trim off the ipfs:// prefix and return the default gateway URL


function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger.throwArgumentError("unsupported IPFS format", "link", link);
  }

  return "https://gateway.ipfs.io/ipfs/".concat(link);
}

function numPad(value) {
  var result = arrayify(value);

  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }

  var padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}

function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }

  var result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
} // ABI Encodes a series of (bytes, bytes, ...)


function encodeBytes(datas) {
  var result = [];
  var byteCount = 0; // Add place-holders for pointers as we add items

  for (var i = 0; i < datas.length; i++) {
    result.push(null);
    byteCount += 32;
  }

  for (var _i = 0; _i < datas.length; _i++) {
    var data = arrayify(datas[_i]); // Update the bytes offset

    result[_i] = numPad(byteCount); // The length and padded value of data

    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }

  return hexConcat(result);
}

export var Resolver = /*#__PURE__*/function () {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  function Resolver(provider, address, name, resolvedAddress) {
    _classCallCheck(this, Resolver);

    defineReadOnly(this, "provider", provider);
    defineReadOnly(this, "name", name);
    defineReadOnly(this, "address", provider.formatter.address(address));
    defineReadOnly(this, "_resolvedAddress", resolvedAddress);
  }

  _createClass(Resolver, [{
    key: "supportsWildcard",
    value: function supportsWildcard() {
      var _this = this;

      if (!this._supportsEip2544) {
        // supportsInterface(bytes4 = selector("resolve(bytes,bytes)"))
        this._supportsEip2544 = this.provider.call({
          to: this.address,
          data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
        }).then(function (result) {
          return BigNumber.from(result).eq(1);
        }).catch(function (error) {
          if (error.code === Logger.errors.CALL_EXCEPTION) {
            return false;
          } // Rethrow the error: link is down, etc. Let future attempts retry.


          _this._supportsEip2544 = null;
          throw error;
        });
      }

      return this._supportsEip2544;
    }
  }, {
    key: "_fetch",
    value: function _fetch(selector, parameters) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var tx, parseBytes, result;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // e.g. keccak256("addr(bytes32,uint256)")
                tx = {
                  to: this.address,
                  ccipReadEnabled: true,
                  data: hexConcat([selector, namehash(this.name), parameters || "0x"])
                }; // Wildcard support; use EIP-2544 to resolve the request

                parseBytes = false;
                _context.next = 4;
                return this.supportsWildcard();

              case 4:
                if (!_context.sent) {
                  _context.next = 7;
                  break;
                }

                parseBytes = true; // selector("resolve(bytes,bytes)")

                tx.data = hexConcat(["0x9061b923", encodeBytes([dnsEncode(this.name), tx.data])]);

              case 7:
                _context.prev = 7;
                _context.next = 10;
                return this.provider.call(tx);

              case 10:
                result = _context.sent;

                if (arrayify(result).length % 32 === 4) {
                  logger.throwError("resolver threw error", Logger.errors.CALL_EXCEPTION, {
                    transaction: tx,
                    data: result
                  });
                }

                if (parseBytes) {
                  result = _parseBytes(result, 0);
                }

                return _context.abrupt("return", result);

              case 16:
                _context.prev = 16;
                _context.t0 = _context["catch"](7);

                if (!(_context.t0.code === Logger.errors.CALL_EXCEPTION)) {
                  _context.next = 20;
                  break;
                }

                return _context.abrupt("return", null);

              case 20:
                throw _context.t0;

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[7, 16]]);
      }));
    }
  }, {
    key: "_fetchBytes",
    value: function _fetchBytes(selector, parameters) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var result;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this._fetch(selector, parameters);

              case 2:
                result = _context2.sent;

                if (!(result != null)) {
                  _context2.next = 5;
                  break;
                }

                return _context2.abrupt("return", _parseBytes(result, 0));

              case 5:
                return _context2.abrupt("return", null);

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "_getAddress",
    value: function _getAddress(coinType, hexBytes) {
      var coinInfo = coinInfos[String(coinType)];

      if (coinInfo == null) {
        logger.throwError("unsupported coin type: ".concat(coinType), Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress(".concat(coinType, ")")
        });
      }

      if (coinInfo.ilk === "eth") {
        return this.provider.formatter.address(hexBytes);
      }

      var bytes = arrayify(hexBytes); // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

      if (coinInfo.p2pkh != null) {
        var p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);

        if (p2pkh) {
          var length = parseInt(p2pkh[1], 16);

          if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
            return base58Encode(concat([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
          }
        }
      } // P2SH: OP_HASH160 <scriptHash> OP_EQUAL


      if (coinInfo.p2sh != null) {
        var p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);

        if (p2sh) {
          var _length = parseInt(p2sh[1], 16);

          if (p2sh[2].length === _length * 2 && _length >= 1 && _length <= 75) {
            return base58Encode(concat([[coinInfo.p2sh], "0x" + p2sh[2]]));
          }
        }
      } // Bech32


      if (coinInfo.prefix != null) {
        var _length2 = bytes[1]; // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program

        var _version = bytes[0];

        if (_version === 0x00) {
          if (_length2 !== 20 && _length2 !== 32) {
            _version = -1;
          }
        } else {
          _version = -1;
        }

        if (_version >= 0 && bytes.length === 2 + _length2 && _length2 >= 1 && _length2 <= 75) {
          var words = bech32.toWords(bytes.slice(2));
          words.unshift(_version);
          return bech32.encode(coinInfo.prefix, words);
        }
      }

      return null;
    }
  }, {
    key: "getAddress",
    value: function getAddress(coinType) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var result, hexBytes, address;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (coinType == null) {
                  coinType = 60;
                } // If Ethereum, use the standard `addr(bytes32)`


                if (!(coinType === 60)) {
                  _context3.next = 16;
                  break;
                }

                _context3.prev = 2;
                _context3.next = 5;
                return this._fetch("0x3b3b57de");

              case 5:
                result = _context3.sent;

                if (!(result === "0x" || result === HashZero)) {
                  _context3.next = 8;
                  break;
                }

                return _context3.abrupt("return", null);

              case 8:
                return _context3.abrupt("return", this.provider.formatter.callAddress(result));

              case 11:
                _context3.prev = 11;
                _context3.t0 = _context3["catch"](2);

                if (!(_context3.t0.code === Logger.errors.CALL_EXCEPTION)) {
                  _context3.next = 15;
                  break;
                }

                return _context3.abrupt("return", null);

              case 15:
                throw _context3.t0;

              case 16:
                _context3.next = 18;
                return this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));

              case 18:
                hexBytes = _context3.sent;

                if (!(hexBytes == null || hexBytes === "0x")) {
                  _context3.next = 21;
                  break;
                }

                return _context3.abrupt("return", null);

              case 21:
                // Compute the address
                address = this._getAddress(coinType, hexBytes);

                if (address == null) {
                  logger.throwError("invalid or unsupported coin data", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "getAddress(".concat(coinType, ")"),
                    coinType: coinType,
                    data: hexBytes
                  });
                }

                return _context3.abrupt("return", address);

              case 24:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[2, 11]]);
      }));
    }
  }, {
    key: "getAvatar",
    value: function getAvatar() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var linkage, avatar, i, match, scheme, selector, owner, comps, addr, tokenId, tokenOwner, balance, tx, metadataUrl, metadata, imageUrl, ipfs;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                linkage = [{
                  type: "name",
                  content: this.name
                }];
                _context4.prev = 1;
                _context4.next = 4;
                return this.getText("avatar");

              case 4:
                avatar = _context4.sent;

                if (!(avatar == null)) {
                  _context4.next = 7;
                  break;
                }

                return _context4.abrupt("return", null);

              case 7:
                i = 0;

              case 8:
                if (!(i < matchers.length)) {
                  _context4.next = 91;
                  break;
                }

                match = avatar.match(matchers[i]);

                if (!(match == null)) {
                  _context4.next = 12;
                  break;
                }

                return _context4.abrupt("continue", 88);

              case 12:
                scheme = match[1].toLowerCase();
                _context4.t0 = scheme;
                _context4.next = _context4.t0 === "https" ? 16 : _context4.t0 === "data" ? 18 : _context4.t0 === "ipfs" ? 20 : _context4.t0 === "erc721" ? 22 : _context4.t0 === "erc1155" ? 22 : 88;
                break;

              case 16:
                linkage.push({
                  type: "url",
                  content: avatar
                });
                return _context4.abrupt("return", {
                  linkage: linkage,
                  url: avatar
                });

              case 18:
                linkage.push({
                  type: "data",
                  content: avatar
                });
                return _context4.abrupt("return", {
                  linkage: linkage,
                  url: avatar
                });

              case 20:
                linkage.push({
                  type: "ipfs",
                  content: avatar
                });
                return _context4.abrupt("return", {
                  linkage: linkage,
                  url: getIpfsLink(avatar)
                });

              case 22:
                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                linkage.push({
                  type: scheme,
                  content: avatar
                }); // The owner of this name

                _context4.t1 = this._resolvedAddress;

                if (_context4.t1) {
                  _context4.next = 29;
                  break;
                }

                _context4.next = 28;
                return this.getAddress();

              case 28:
                _context4.t1 = _context4.sent;

              case 29:
                owner = _context4.t1;
                comps = (match[2] || "").split("/");

                if (!(comps.length !== 2)) {
                  _context4.next = 33;
                  break;
                }

                return _context4.abrupt("return", null);

              case 33:
                _context4.next = 35;
                return this.provider.formatter.address(comps[0]);

              case 35:
                addr = _context4.sent;
                tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32); // Check that this account owns the token

                if (!(scheme === "erc721")) {
                  _context4.next = 48;
                  break;
                }

                _context4.t2 = this.provider.formatter;
                _context4.next = 41;
                return this.provider.call({
                  to: addr,
                  data: hexConcat(["0x6352211e", tokenId])
                });

              case 41:
                _context4.t3 = _context4.sent;
                tokenOwner = _context4.t2.callAddress.call(_context4.t2, _context4.t3);

                if (!(owner !== tokenOwner)) {
                  _context4.next = 45;
                  break;
                }

                return _context4.abrupt("return", null);

              case 45:
                linkage.push({
                  type: "owner",
                  content: tokenOwner
                });
                _context4.next = 57;
                break;

              case 48:
                if (!(scheme === "erc1155")) {
                  _context4.next = 57;
                  break;
                }

                _context4.t4 = BigNumber;
                _context4.next = 52;
                return this.provider.call({
                  to: addr,
                  data: hexConcat(["0x00fdd58e", hexZeroPad(owner, 32), tokenId])
                });

              case 52:
                _context4.t5 = _context4.sent;
                balance = _context4.t4.from.call(_context4.t4, _context4.t5);

                if (!balance.isZero()) {
                  _context4.next = 56;
                  break;
                }

                return _context4.abrupt("return", null);

              case 56:
                linkage.push({
                  type: "balance",
                  content: balance.toString()
                });

              case 57:
                // Call the token contract for the metadata URL
                tx = {
                  to: this.provider.formatter.address(comps[0]),
                  data: hexConcat([selector, tokenId])
                };
                _context4.t6 = _parseString;
                _context4.next = 61;
                return this.provider.call(tx);

              case 61:
                _context4.t7 = _context4.sent;
                metadataUrl = (0, _context4.t6)(_context4.t7, 0);

                if (!(metadataUrl == null)) {
                  _context4.next = 65;
                  break;
                }

                return _context4.abrupt("return", null);

              case 65:
                linkage.push({
                  type: "metadata-url-base",
                  content: metadataUrl
                }); // ERC-1155 allows a generic {id} in the URL

                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                  linkage.push({
                    type: "metadata-url-expanded",
                    content: metadataUrl
                  });
                } // Transform IPFS metadata links


                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }

                linkage.push({
                  type: "metadata-url",
                  content: metadataUrl
                }); // Get the token metadata

                _context4.next = 71;
                return fetchJson(metadataUrl);

              case 71:
                metadata = _context4.sent;

                if (metadata) {
                  _context4.next = 74;
                  break;
                }

                return _context4.abrupt("return", null);

              case 74:
                linkage.push({
                  type: "metadata",
                  content: JSON.stringify(metadata)
                }); // Pull the image URL out

                imageUrl = metadata.image;

                if (!(typeof imageUrl !== "string")) {
                  _context4.next = 78;
                  break;
                }

                return _context4.abrupt("return", null);

              case 78:
                if (!imageUrl.match(/^(https:\/\/|data:)/i)) {
                  _context4.next = 81;
                  break;
                }

                _context4.next = 86;
                break;

              case 81:
                // Transform IPFS link to gateway
                ipfs = imageUrl.match(matcherIpfs);

                if (!(ipfs == null)) {
                  _context4.next = 84;
                  break;
                }

                return _context4.abrupt("return", null);

              case 84:
                linkage.push({
                  type: "url-ipfs",
                  content: imageUrl
                });
                imageUrl = getIpfsLink(imageUrl);

              case 86:
                linkage.push({
                  type: "url",
                  content: imageUrl
                });
                return _context4.abrupt("return", {
                  linkage: linkage,
                  url: imageUrl
                });

              case 88:
                i++;
                _context4.next = 8;
                break;

              case 91:
                _context4.next = 95;
                break;

              case 93:
                _context4.prev = 93;
                _context4.t8 = _context4["catch"](1);

              case 95:
                return _context4.abrupt("return", null);

              case 96:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this, [[1, 93]]);
      }));
    }
  }, {
    key: "getContentHash",
    value: function getContentHash() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var hexBytes, ipfs, length, ipns, _length3, swarm;

        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this._fetchBytes("0xbc1c58d1");

              case 2:
                hexBytes = _context5.sent;

                if (!(hexBytes == null || hexBytes === "0x")) {
                  _context5.next = 5;
                  break;
                }

                return _context5.abrupt("return", null);

              case 5:
                // IPFS (CID: 1, Type: DAG-PB)
                ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);

                if (!ipfs) {
                  _context5.next = 10;
                  break;
                }

                length = parseInt(ipfs[3], 16);

                if (!(ipfs[4].length === length * 2)) {
                  _context5.next = 10;
                  break;
                }

                return _context5.abrupt("return", "ipfs:/\/" + Base58.encode("0x" + ipfs[1]));

              case 10:
                // IPNS (CID: 1, Type: libp2p-key)
                ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);

                if (!ipns) {
                  _context5.next = 15;
                  break;
                }

                _length3 = parseInt(ipns[3], 16);

                if (!(ipns[4].length === _length3 * 2)) {
                  _context5.next = 15;
                  break;
                }

                return _context5.abrupt("return", "ipns:/\/" + Base58.encode("0x" + ipns[1]));

              case 15:
                // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
                swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);

                if (!swarm) {
                  _context5.next = 19;
                  break;
                }

                if (!(swarm[1].length === 32 * 2)) {
                  _context5.next = 19;
                  break;
                }

                return _context5.abrupt("return", "bzz:/\/" + swarm[1]);

              case 19:
                return _context5.abrupt("return", logger.throwError("invalid or unsupported content hash data", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "getContentHash()",
                  data: hexBytes
                }));

              case 20:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
    }
  }, {
    key: "getText",
    value: function getText(key) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var keyBytes, hexBytes;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                // The key encoded as parameter to fetchBytes
                keyBytes = toUtf8Bytes(key); // The nodehash consumes the first slot, so the string pointer targets
                // offset 64, with the length at offset 64 and data starting at offset 96

                keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]); // Pad to word-size (32 bytes)

                if (keyBytes.length % 32 !== 0) {
                  keyBytes = concat([keyBytes, hexZeroPad("0x", 32 - key.length % 32)]);
                }

                _context6.next = 5;
                return this._fetchBytes("0x59d1d43c", hexlify(keyBytes));

              case 5:
                hexBytes = _context6.sent;

                if (!(hexBytes == null || hexBytes === "0x")) {
                  _context6.next = 8;
                  break;
                }

                return _context6.abrupt("return", null);

              case 8:
                return _context6.abrupt("return", toUtf8String(hexBytes));

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
    }
  }]);

  return Resolver;
}();
var defaultFormatter = null;
var nextPollId = 1;
export var BaseProvider = /*#__PURE__*/function (_Provider) {
  _inherits(BaseProvider, _Provider);

  var _super = _createSuper(BaseProvider);

  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  function BaseProvider(network) {
    var _this2;

    _classCallCheck(this, BaseProvider);

    logger.checkNew(this instanceof BaseProvider ? this.constructor : void 0, Provider);
    _this2 = _super.call(this); // Events being listened to

    _this2._events = [];
    _this2._emitted = {
      block: -2
    };
    _this2.disableCcipRead = false;
    _this2.formatter = (this instanceof BaseProvider ? this.constructor : void 0).getFormatter(); // If network is any, this Provider allows the underlying
    // network to change dynamically, and we auto-detect the
    // current network

    defineReadOnly(_assertThisInitialized(_this2), "anyNetwork", network === "any");

    if (_this2.anyNetwork) {
      network = _this2.detectNetwork();
    }

    if (network instanceof Promise) {
      _this2._networkPromise = network; // Squash any "unhandled promise" errors; that do not need to be handled

      network.catch(function (error) {}); // Trigger initial network setting (async)

      _this2._ready().catch(function (error) {});
    } else {
      var knownNetwork = getStatic(this instanceof BaseProvider ? this.constructor : void 0, "getNetwork")(network);

      if (knownNetwork) {
        defineReadOnly(_assertThisInitialized(_this2), "_network", knownNetwork);

        _this2.emit("network", knownNetwork, null);
      } else {
        logger.throwArgumentError("invalid network", "network", network);
      }
    }

    _this2._maxInternalBlockNumber = -1024;
    _this2._lastBlockNumber = -2;
    _this2._maxFilterBlockRange = 10;
    _this2._pollingInterval = 4000;
    _this2._fastQueryDate = 0;
    return _this2;
  }

  _createClass(BaseProvider, [{
    key: "_ready",
    value: function _ready() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
        var network;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (!(this._network == null)) {
                  _context7.next = 17;
                  break;
                }

                network = null;

                if (!this._networkPromise) {
                  _context7.next = 11;
                  break;
                }

                _context7.prev = 3;
                _context7.next = 6;
                return this._networkPromise;

              case 6:
                network = _context7.sent;
                _context7.next = 11;
                break;

              case 9:
                _context7.prev = 9;
                _context7.t0 = _context7["catch"](3);

              case 11:
                if (!(network == null)) {
                  _context7.next = 15;
                  break;
                }

                _context7.next = 14;
                return this.detectNetwork();

              case 14:
                network = _context7.sent;

              case 15:
                // This should never happen; every Provider sub-class should have
                // suggested a network by here (or have thrown).
                if (!network) {
                  logger.throwError("no network detected", Logger.errors.UNKNOWN_ERROR, {});
                } // Possible this call stacked so do not call defineReadOnly again


                if (this._network == null) {
                  if (this.anyNetwork) {
                    this._network = network;
                  } else {
                    defineReadOnly(this, "_network", network);
                  }

                  this.emit("network", network, null);
                }

              case 17:
                return _context7.abrupt("return", this._network);

              case 18:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this, [[3, 9]]);
      }));
    } // This will always return the most recently established network.
    // For "any", this can change (a "network" event is emitted before
    // any change is reflected); otherwise this cannot change

  }, {
    key: "ready",
    get: function get() {
      var _this3 = this;

      return poll(function () {
        return _this3._ready().then(function (network) {
          return network;
        }, function (error) {
          // If the network isn't running yet, we will wait
          if (error.code === Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
            return undefined;
          }

          throw error;
        });
      });
    } // @TODO: Remove this and just create a singleton formatter

  }, {
    key: "ccipReadFetch",
    value: function ccipReadFetch(tx, calldata, urls) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
        var sender, data, errorMessages, i, url, href, json, result, errorMessage;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (!(this.disableCcipRead || urls.length === 0)) {
                  _context8.next = 2;
                  break;
                }

                return _context8.abrupt("return", null);

              case 2:
                sender = tx.to.toLowerCase();
                data = calldata.toLowerCase();
                errorMessages = [];
                i = 0;

              case 6:
                if (!(i < urls.length)) {
                  _context8.next = 22;
                  break;
                }

                url = urls[i]; // URL expansion

                href = url.replace("{sender}", sender).replace("{data}", data); // If no {data} is present, use POST; otherwise GET

                json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({
                  data: data,
                  sender: sender
                });
                _context8.next = 12;
                return fetchJson({
                  url: href,
                  errorPassThrough: true
                }, json, function (value, response) {
                  value.status = response.statusCode;
                  return value;
                });

              case 12:
                result = _context8.sent;

                if (!result.data) {
                  _context8.next = 15;
                  break;
                }

                return _context8.abrupt("return", result.data);

              case 15:
                errorMessage = result.message || "unknown error"; // 4xx indicates the result is not present; stop

                if (!(result.status >= 400 && result.status < 500)) {
                  _context8.next = 18;
                  break;
                }

                return _context8.abrupt("return", logger.throwError("response not found during CCIP fetch: ".concat(errorMessage), Logger.errors.SERVER_ERROR, {
                  url: url,
                  errorMessage: errorMessage
                }));

              case 18:
                // 5xx indicates server issue; try the next url
                errorMessages.push(errorMessage);

              case 19:
                i++;
                _context8.next = 6;
                break;

              case 22:
                return _context8.abrupt("return", logger.throwError("error encountered during CCIP fetch: ".concat(errorMessages.map(function (m) {
                  return JSON.stringify(m);
                }).join(", ")), Logger.errors.SERVER_ERROR, {
                  urls: urls,
                  errorMessages: errorMessages
                }));

              case 23:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
    } // Fetches the blockNumber, but will reuse any result that is less
    // than maxAge old or has been requested since the last request

  }, {
    key: "_getInternalBlockNumber",
    value: function _getInternalBlockNumber(maxAge) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        var _this4 = this;

        var internalBlockNumber, result, reqTime, checkInternalBlockNumber;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                _context9.next = 2;
                return this._ready();

              case 2:
                if (!(maxAge > 0)) {
                  _context9.next = 20;
                  break;
                }

              case 3:
                if (!this._internalBlockNumber) {
                  _context9.next = 20;
                  break;
                }

                // ..."remember" which fetch we started with
                internalBlockNumber = this._internalBlockNumber;
                _context9.prev = 5;
                _context9.next = 8;
                return internalBlockNumber;

              case 8:
                result = _context9.sent;

                if (!(getTime() - result.respTime <= maxAge)) {
                  _context9.next = 11;
                  break;
                }

                return _context9.abrupt("return", result.blockNumber);

              case 11:
                return _context9.abrupt("break", 20);

              case 14:
                _context9.prev = 14;
                _context9.t0 = _context9["catch"](5);

                if (!(this._internalBlockNumber === internalBlockNumber)) {
                  _context9.next = 18;
                  break;
                }

                return _context9.abrupt("break", 20);

              case 18:
                _context9.next = 3;
                break;

              case 20:
                reqTime = getTime();
                checkInternalBlockNumber = resolveProperties({
                  blockNumber: this.perform("getBlockNumber", {}),
                  networkError: this.getNetwork().then(function (network) {
                    return null;
                  }, function (error) {
                    return error;
                  })
                }).then(function (_ref) {
                  var blockNumber = _ref.blockNumber,
                      networkError = _ref.networkError;

                  if (networkError) {
                    // Unremember this bad internal block number
                    if (_this4._internalBlockNumber === checkInternalBlockNumber) {
                      _this4._internalBlockNumber = null;
                    }

                    throw networkError;
                  }

                  var respTime = getTime();
                  blockNumber = BigNumber.from(blockNumber).toNumber();

                  if (blockNumber < _this4._maxInternalBlockNumber) {
                    blockNumber = _this4._maxInternalBlockNumber;
                  }

                  _this4._maxInternalBlockNumber = blockNumber;

                  _this4._setFastBlockNumber(blockNumber); // @TODO: Still need this?


                  return {
                    blockNumber: blockNumber,
                    reqTime: reqTime,
                    respTime: respTime
                  };
                });
                this._internalBlockNumber = checkInternalBlockNumber; // Swallow unhandled exceptions; if needed they are handled else where

                checkInternalBlockNumber.catch(function (error) {
                  // Don't null the dead (rejected) fetch, if it has already been updated
                  if (_this4._internalBlockNumber === checkInternalBlockNumber) {
                    _this4._internalBlockNumber = null;
                  }
                });
                _context9.next = 26;
                return checkInternalBlockNumber;

              case 26:
                return _context9.abrupt("return", _context9.sent.blockNumber);

              case 27:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[5, 14]]);
      }));
    }
  }, {
    key: "poll",
    value: function poll() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
        var _this5 = this;

        var pollId, runners, blockNumber, i;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                pollId = nextPollId++; // Track all running promises, so we can trigger a post-poll once they are complete

                runners = [];
                blockNumber = null;
                _context10.prev = 3;
                _context10.next = 6;
                return this._getInternalBlockNumber(100 + this.pollingInterval / 2);

              case 6:
                blockNumber = _context10.sent;
                _context10.next = 13;
                break;

              case 9:
                _context10.prev = 9;
                _context10.t0 = _context10["catch"](3);
                this.emit("error", _context10.t0);
                return _context10.abrupt("return");

              case 13:
                this._setFastBlockNumber(blockNumber); // Emit a poll event after we have the latest (fast) block number


                this.emit("poll", pollId, blockNumber); // If the block has not changed, meh.

                if (!(blockNumber === this._lastBlockNumber)) {
                  _context10.next = 18;
                  break;
                }

                this.emit("didPoll", pollId);
                return _context10.abrupt("return");

              case 18:
                // First polling cycle, trigger a "block" events
                if (this._emitted.block === -2) {
                  this._emitted.block = blockNumber - 1;
                }

                if (Math.abs(this._emitted.block - blockNumber) > 1000) {
                  logger.warn("network block skew detected; skipping block events (emitted=".concat(this._emitted.block, " blockNumber").concat(blockNumber, ")"));
                  this.emit("error", logger.makeError("network block skew detected", Logger.errors.NETWORK_ERROR, {
                    blockNumber: blockNumber,
                    event: "blockSkew",
                    previousBlockNumber: this._emitted.block
                  }));
                  this.emit("block", blockNumber);
                } else {
                  // Notify all listener for each block that has passed
                  for (i = this._emitted.block + 1; i <= blockNumber; i++) {
                    this.emit("block", i);
                  }
                } // The emitted block was updated, check for obsolete events


                if (this._emitted.block !== blockNumber) {
                  this._emitted.block = blockNumber;
                  Object.keys(this._emitted).forEach(function (key) {
                    // The block event does not expire
                    if (key === "block") {
                      return;
                    } // The block we were at when we emitted this event


                    var eventBlockNumber = _this5._emitted[key]; // We cannot garbage collect pending transactions or blocks here
                    // They should be garbage collected by the Provider when setting
                    // "pending" events

                    if (eventBlockNumber === "pending") {
                      return;
                    } // Evict any transaction hashes or block hashes over 12 blocks
                    // old, since they should not return null anyways


                    if (blockNumber - eventBlockNumber > 12) {
                      delete _this5._emitted[key];
                    }
                  });
                } // First polling cycle


                if (this._lastBlockNumber === -2) {
                  this._lastBlockNumber = blockNumber - 1;
                } // Find all transaction hashes we are waiting on


                this._events.forEach(function (event) {
                  switch (event.type) {
                    case "tx":
                      {
                        var hash = event.hash;

                        var runner = _this5.getTransactionReceipt(hash).then(function (receipt) {
                          if (!receipt || receipt.blockNumber == null) {
                            return null;
                          }

                          _this5._emitted["t:" + hash] = receipt.blockNumber;

                          _this5.emit(hash, receipt);

                          return null;
                        }).catch(function (error) {
                          _this5.emit("error", error);
                        });

                        runners.push(runner);
                        break;
                      }

                    case "filter":
                      {
                        // We only allow a single getLogs to be in-flight at a time
                        if (!event._inflight) {
                          event._inflight = true; // Filter from the last known event; due to load-balancing
                          // and some nodes returning updated block numbers before
                          // indexing events, a logs result with 0 entries cannot be
                          // trusted and we must retry a range which includes it again

                          var filter = event.filter;
                          filter.fromBlock = event._lastBlockNumber + 1;
                          filter.toBlock = blockNumber; // Prevent fitler ranges from growing too wild

                          if (filter.toBlock - _this5._maxFilterBlockRange > filter.fromBlock) {
                            filter.fromBlock = filter.toBlock - _this5._maxFilterBlockRange;
                          }

                          var _runner = _this5.getLogs(filter).then(function (logs) {
                            // Allow the next getLogs
                            event._inflight = false;

                            if (logs.length === 0) {
                              return;
                            }

                            logs.forEach(function (log) {
                              // Only when we get an event for a given block number
                              // can we trust the events are indexed
                              if (log.blockNumber > event._lastBlockNumber) {
                                event._lastBlockNumber = log.blockNumber;
                              } // Make sure we stall requests to fetch blocks and txs


                              _this5._emitted["b:" + log.blockHash] = log.blockNumber;
                              _this5._emitted["t:" + log.transactionHash] = log.blockNumber;

                              _this5.emit(filter, log);
                            });
                          }).catch(function (error) {
                            _this5.emit("error", error); // Allow another getLogs (the range was not updated)


                            event._inflight = false;
                          });

                          runners.push(_runner);
                        }

                        break;
                      }
                  }
                });

                this._lastBlockNumber = blockNumber; // Once all events for this loop have been processed, emit "didPoll"

                Promise.all(runners).then(function () {
                  _this5.emit("didPoll", pollId);
                }).catch(function (error) {
                  _this5.emit("error", error);
                });
                return _context10.abrupt("return");

              case 26:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this, [[3, 9]]);
      }));
    } // Deprecated; do not use this

  }, {
    key: "resetEventsBlock",
    value: function resetEventsBlock(blockNumber) {
      this._lastBlockNumber = blockNumber - 1;

      if (this.polling) {
        this.poll();
      }
    }
  }, {
    key: "network",
    get: function get() {
      return this._network;
    } // This method should query the network if the underlying network
    // can change, such as when connected to a JSON-RPC backend

  }, {
    key: "detectNetwork",
    value: function detectNetwork() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                return _context11.abrupt("return", logger.throwError("provider does not support network detection", Logger.errors.UNSUPPORTED_OPERATION, {
                  operation: "provider.detectNetwork"
                }));

              case 1:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }));
    }
  }, {
    key: "getNetwork",
    value: function getNetwork() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {
        var network, currentNetwork, error;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return this._ready();

              case 2:
                network = _context12.sent;
                _context12.next = 5;
                return this.detectNetwork();

              case 5:
                currentNetwork = _context12.sent;

                if (!(network.chainId !== currentNetwork.chainId)) {
                  _context12.next = 23;
                  break;
                }

                if (!this.anyNetwork) {
                  _context12.next = 20;
                  break;
                }

                this._network = currentNetwork; // Reset all internal block number guards and caches

                this._lastBlockNumber = -2;
                this._fastBlockNumber = null;
                this._fastBlockNumberPromise = null;
                this._fastQueryDate = 0;
                this._emitted.block = -2;
                this._maxInternalBlockNumber = -1024;
                this._internalBlockNumber = null; // The "network" event MUST happen before this method resolves
                // so any events have a chance to unregister, so we stall an
                // additional event loop before returning from /this/ call

                this.emit("network", currentNetwork, network);
                _context12.next = 19;
                return stall(0);

              case 19:
                return _context12.abrupt("return", this._network);

              case 20:
                error = logger.makeError("underlying network changed", Logger.errors.NETWORK_ERROR, {
                  event: "changed",
                  network: network,
                  detectedNetwork: currentNetwork
                });
                this.emit("error", error);
                throw error;

              case 23:
                return _context12.abrupt("return", network);

              case 24:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));
    }
  }, {
    key: "blockNumber",
    get: function get() {
      var _this6 = this;

      this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(function (blockNumber) {
        _this6._setFastBlockNumber(blockNumber);
      }, function (error) {});

      return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
    }
  }, {
    key: "polling",
    get: function get() {
      return this._poller != null;
    },
    set: function set(value) {
      var _this7 = this;

      if (value && !this._poller) {
        this._poller = setInterval(function () {
          _this7.poll();
        }, this.pollingInterval);

        if (!this._bootstrapPoll) {
          this._bootstrapPoll = setTimeout(function () {
            _this7.poll(); // We block additional polls until the polling interval
            // is done, to prevent overwhelming the poll function


            _this7._bootstrapPoll = setTimeout(function () {
              // If polling was disabled, something may require a poke
              // since starting the bootstrap poll and it was disabled
              if (!_this7._poller) {
                _this7.poll();
              } // Clear out the bootstrap so we can do another


              _this7._bootstrapPoll = null;
            }, _this7.pollingInterval);
          }, 0);
        }
      } else if (!value && this._poller) {
        clearInterval(this._poller);
        this._poller = null;
      }
    }
  }, {
    key: "pollingInterval",
    get: function get() {
      return this._pollingInterval;
    },
    set: function set(value) {
      var _this8 = this;

      if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
        throw new Error("invalid polling interval");
      }

      this._pollingInterval = value;

      if (this._poller) {
        clearInterval(this._poller);
        this._poller = setInterval(function () {
          _this8.poll();
        }, this._pollingInterval);
      }
    }
  }, {
    key: "_getFastBlockNumber",
    value: function _getFastBlockNumber() {
      var _this9 = this;

      var now = getTime(); // Stale block number, request a newer value

      if (now - this._fastQueryDate > 2 * this._pollingInterval) {
        this._fastQueryDate = now;
        this._fastBlockNumberPromise = this.getBlockNumber().then(function (blockNumber) {
          if (_this9._fastBlockNumber == null || blockNumber > _this9._fastBlockNumber) {
            _this9._fastBlockNumber = blockNumber;
          }

          return _this9._fastBlockNumber;
        });
      }

      return this._fastBlockNumberPromise;
    }
  }, {
    key: "_setFastBlockNumber",
    value: function _setFastBlockNumber(blockNumber) {
      // Older block, maybe a stale request
      if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
        return;
      } // Update the time we updated the blocknumber


      this._fastQueryDate = getTime(); // Newer block number, use  it

      if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
        this._fastBlockNumber = blockNumber;
        this._fastBlockNumberPromise = Promise.resolve(blockNumber);
      }
    }
  }, {
    key: "waitForTransaction",
    value: function waitForTransaction(transactionHash, confirmations, timeout) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                return _context13.abrupt("return", this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null));

              case 1:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));
    }
  }, {
    key: "_waitForTransaction",
    value: function _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee16() {
        var _this10 = this;

        var receipt;
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _context16.next = 2;
                return this.getTransactionReceipt(transactionHash);

              case 2:
                receipt = _context16.sent;

                if (!((receipt ? receipt.confirmations : 0) >= confirmations)) {
                  _context16.next = 5;
                  break;
                }

                return _context16.abrupt("return", receipt);

              case 5:
                return _context16.abrupt("return", new Promise(function (resolve, reject) {
                  var cancelFuncs = [];
                  var done = false;

                  var alreadyDone = function alreadyDone() {
                    if (done) {
                      return true;
                    }

                    done = true;
                    cancelFuncs.forEach(function (func) {
                      func();
                    });
                    return false;
                  };

                  var minedHandler = function minedHandler(receipt) {
                    if (receipt.confirmations < confirmations) {
                      return;
                    }

                    if (alreadyDone()) {
                      return;
                    }

                    resolve(receipt);
                  };

                  _this10.on(transactionHash, minedHandler);

                  cancelFuncs.push(function () {
                    _this10.removeListener(transactionHash, minedHandler);
                  });

                  if (replaceable) {
                    var lastBlockNumber = replaceable.startBlock;
                    var scannedBlock = null;

                    var replaceHandler = function replaceHandler(blockNumber) {
                      return __awaiter(_this10, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {
                        var _this11 = this;

                        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
                          while (1) {
                            switch (_context15.prev = _context15.next) {
                              case 0:
                                if (!done) {
                                  _context15.next = 2;
                                  break;
                                }

                                return _context15.abrupt("return");

                              case 2:
                                _context15.next = 4;
                                return stall(1000);

                              case 4:
                                this.getTransactionCount(replaceable.from).then(function (nonce) {
                                  return __awaiter(_this11, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {
                                    var mined, block, ti, tx, _receipt, reason;

                                    return _regeneratorRuntime.wrap(function _callee14$(_context14) {
                                      while (1) {
                                        switch (_context14.prev = _context14.next) {
                                          case 0:
                                            if (!done) {
                                              _context14.next = 2;
                                              break;
                                            }

                                            return _context14.abrupt("return");

                                          case 2:
                                            if (!(nonce <= replaceable.nonce)) {
                                              _context14.next = 6;
                                              break;
                                            }

                                            lastBlockNumber = blockNumber;
                                            _context14.next = 41;
                                            break;

                                          case 6:
                                            _context14.next = 8;
                                            return this.getTransaction(transactionHash);

                                          case 8:
                                            mined = _context14.sent;

                                            if (!(mined && mined.blockNumber != null)) {
                                              _context14.next = 11;
                                              break;
                                            }

                                            return _context14.abrupt("return");

                                          case 11:
                                            // First time scanning. We start a little earlier for some
                                            // wiggle room here to handle the eventually consistent nature
                                            // of blockchain (e.g. the getTransactionCount was for a
                                            // different block)
                                            if (scannedBlock == null) {
                                              scannedBlock = lastBlockNumber - 3;

                                              if (scannedBlock < replaceable.startBlock) {
                                                scannedBlock = replaceable.startBlock;
                                              }
                                            }

                                          case 12:
                                            if (!(scannedBlock <= blockNumber)) {
                                              _context14.next = 41;
                                              break;
                                            }

                                            if (!done) {
                                              _context14.next = 15;
                                              break;
                                            }

                                            return _context14.abrupt("return");

                                          case 15:
                                            _context14.next = 17;
                                            return this.getBlockWithTransactions(scannedBlock);

                                          case 17:
                                            block = _context14.sent;
                                            ti = 0;

                                          case 19:
                                            if (!(ti < block.transactions.length)) {
                                              _context14.next = 38;
                                              break;
                                            }

                                            tx = block.transactions[ti]; // Successfully mined!

                                            if (!(tx.hash === transactionHash)) {
                                              _context14.next = 23;
                                              break;
                                            }

                                            return _context14.abrupt("return");

                                          case 23:
                                            if (!(tx.from === replaceable.from && tx.nonce === replaceable.nonce)) {
                                              _context14.next = 35;
                                              break;
                                            }

                                            if (!done) {
                                              _context14.next = 26;
                                              break;
                                            }

                                            return _context14.abrupt("return");

                                          case 26:
                                            _context14.next = 28;
                                            return this.waitForTransaction(tx.hash, confirmations);

                                          case 28:
                                            _receipt = _context14.sent;

                                            if (!alreadyDone()) {
                                              _context14.next = 31;
                                              break;
                                            }

                                            return _context14.abrupt("return");

                                          case 31:
                                            // The reason we were replaced
                                            reason = "replaced";

                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                                              reason = "repriced";
                                            } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                                              reason = "cancelled";
                                            } // Explain why we were replaced


                                            // Explain why we were replaced
                                            reject(logger.makeError("transaction was replaced", Logger.errors.TRANSACTION_REPLACED, {
                                              cancelled: reason === "replaced" || reason === "cancelled",
                                              reason: reason,
                                              replacement: this._wrapTransaction(tx),
                                              hash: transactionHash,
                                              receipt: _receipt
                                            }));
                                            return _context14.abrupt("return");

                                          case 35:
                                            ti++;
                                            _context14.next = 19;
                                            break;

                                          case 38:
                                            scannedBlock++;
                                            _context14.next = 12;
                                            break;

                                          case 41:
                                            if (!done) {
                                              _context14.next = 43;
                                              break;
                                            }

                                            return _context14.abrupt("return");

                                          case 43:
                                            this.once("block", replaceHandler);

                                          case 44:
                                          case "end":
                                            return _context14.stop();
                                        }
                                      }
                                    }, _callee14, this);
                                  }));
                                }, function (error) {
                                  if (done) {
                                    return;
                                  }

                                  _this11.once("block", replaceHandler);
                                });

                              case 5:
                              case "end":
                                return _context15.stop();
                            }
                          }
                        }, _callee15, this);
                      }));
                    };

                    if (done) {
                      return;
                    }

                    _this10.once("block", replaceHandler);

                    cancelFuncs.push(function () {
                      _this10.removeListener("block", replaceHandler);
                    });
                  }

                  if (typeof timeout === "number" && timeout > 0) {
                    var timer = setTimeout(function () {
                      if (alreadyDone()) {
                        return;
                      }

                      reject(logger.makeError("timeout exceeded", Logger.errors.TIMEOUT, {
                        timeout: timeout
                      }));
                    }, timeout);

                    if (timer.unref) {
                      timer.unref();
                    }

                    cancelFuncs.push(function () {
                      clearTimeout(timer);
                    });
                  }
                }));

              case 6:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));
    }
  }, {
    key: "getBlockNumber",
    value: function getBlockNumber() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                return _context17.abrupt("return", this._getInternalBlockNumber(0));

              case 1:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));
    }
  }, {
    key: "getGasPrice",
    value: function getGasPrice() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee18() {
        var result;
        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _context18.next = 2;
                return this.getNetwork();

              case 2:
                _context18.next = 4;
                return this.perform("getGasPrice", {});

              case 4:
                result = _context18.sent;
                _context18.prev = 5;
                return _context18.abrupt("return", BigNumber.from(result));

              case 9:
                _context18.prev = 9;
                _context18.t0 = _context18["catch"](5);
                return _context18.abrupt("return", logger.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                  method: "getGasPrice",
                  result: result,
                  error: _context18.t0
                }));

              case 12:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this, [[5, 9]]);
      }));
    }
  }, {
    key: "getBalance",
    value: function getBalance(addressOrName, blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee19() {
        var params, result;
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                _context19.next = 2;
                return this.getNetwork();

              case 2:
                _context19.next = 4;
                return resolveProperties({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                });

              case 4:
                params = _context19.sent;
                _context19.next = 7;
                return this.perform("getBalance", params);

              case 7:
                result = _context19.sent;
                _context19.prev = 8;
                return _context19.abrupt("return", BigNumber.from(result));

              case 12:
                _context19.prev = 12;
                _context19.t0 = _context19["catch"](8);
                return _context19.abrupt("return", logger.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                  method: "getBalance",
                  params: params,
                  result: result,
                  error: _context19.t0
                }));

              case 15:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this, [[8, 12]]);
      }));
    }
  }, {
    key: "getTransactionCount",
    value: function getTransactionCount(addressOrName, blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee20() {
        var params, result;
        return _regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _context20.next = 2;
                return this.getNetwork();

              case 2:
                _context20.next = 4;
                return resolveProperties({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                });

              case 4:
                params = _context20.sent;
                _context20.next = 7;
                return this.perform("getTransactionCount", params);

              case 7:
                result = _context20.sent;
                _context20.prev = 8;
                return _context20.abrupt("return", BigNumber.from(result).toNumber());

              case 12:
                _context20.prev = 12;
                _context20.t0 = _context20["catch"](8);
                return _context20.abrupt("return", logger.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                  method: "getTransactionCount",
                  params: params,
                  result: result,
                  error: _context20.t0
                }));

              case 15:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this, [[8, 12]]);
      }));
    }
  }, {
    key: "getCode",
    value: function getCode(addressOrName, blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee21() {
        var params, result;
        return _regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _context21.next = 2;
                return this.getNetwork();

              case 2:
                _context21.next = 4;
                return resolveProperties({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag)
                });

              case 4:
                params = _context21.sent;
                _context21.next = 7;
                return this.perform("getCode", params);

              case 7:
                result = _context21.sent;
                _context21.prev = 8;
                return _context21.abrupt("return", hexlify(result));

              case 12:
                _context21.prev = 12;
                _context21.t0 = _context21["catch"](8);
                return _context21.abrupt("return", logger.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                  method: "getCode",
                  params: params,
                  result: result,
                  error: _context21.t0
                }));

              case 15:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this, [[8, 12]]);
      }));
    }
  }, {
    key: "getStorageAt",
    value: function getStorageAt(addressOrName, position, blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee22() {
        var params, result;
        return _regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _context22.next = 2;
                return this.getNetwork();

              case 2:
                _context22.next = 4;
                return resolveProperties({
                  address: this._getAddress(addressOrName),
                  blockTag: this._getBlockTag(blockTag),
                  position: Promise.resolve(position).then(function (p) {
                    return hexValue(p);
                  })
                });

              case 4:
                params = _context22.sent;
                _context22.next = 7;
                return this.perform("getStorageAt", params);

              case 7:
                result = _context22.sent;
                _context22.prev = 8;
                return _context22.abrupt("return", hexlify(result));

              case 12:
                _context22.prev = 12;
                _context22.t0 = _context22["catch"](8);
                return _context22.abrupt("return", logger.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                  method: "getStorageAt",
                  params: params,
                  result: result,
                  error: _context22.t0
                }));

              case 15:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this, [[8, 12]]);
      }));
    } // This should be called by any subclass wrapping a TransactionResponse

  }, {
    key: "_wrapTransaction",
    value: function _wrapTransaction(tx, hash, startBlock) {
      var _this12 = this;

      if (hash != null && hexDataLength(hash) !== 32) {
        throw new Error("invalid response - sendTransaction");
      }

      var result = tx; // Check the hash we expect is the same as the hash the server reported

      if (hash != null && tx.hash !== hash) {
        logger.throwError("Transaction hash mismatch from Provider.sendTransaction.", Logger.errors.UNKNOWN_ERROR, {
          expectedHash: tx.hash,
          returnedHash: hash
        });
      }

      result.wait = function (confirms, timeout) {
        return __awaiter(_this12, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee23() {
          var replacement, receipt;
          return _regeneratorRuntime.wrap(function _callee23$(_context23) {
            while (1) {
              switch (_context23.prev = _context23.next) {
                case 0:
                  if (confirms == null) {
                    confirms = 1;
                  }

                  if (timeout == null) {
                    timeout = 0;
                  } // Get the details to detect replacement


                  replacement = undefined;

                  if (confirms !== 0 && startBlock != null) {
                    replacement = {
                      data: tx.data,
                      from: tx.from,
                      nonce: tx.nonce,
                      to: tx.to,
                      value: tx.value,
                      startBlock: startBlock
                    };
                  }

                  _context23.next = 6;
                  return this._waitForTransaction(tx.hash, confirms, timeout, replacement);

                case 6:
                  receipt = _context23.sent;

                  if (!(receipt == null && confirms === 0)) {
                    _context23.next = 9;
                    break;
                  }

                  return _context23.abrupt("return", null);

                case 9:
                  // No longer pending, allow the polling loop to garbage collect this
                  this._emitted["t:" + tx.hash] = receipt.blockNumber;

                  if (receipt.status === 0) {
                    logger.throwError("transaction failed", Logger.errors.CALL_EXCEPTION, {
                      transactionHash: tx.hash,
                      transaction: tx,
                      receipt: receipt
                    });
                  }

                  return _context23.abrupt("return", receipt);

                case 12:
                case "end":
                  return _context23.stop();
              }
            }
          }, _callee23, this);
        }));
      };

      return result;
    }
  }, {
    key: "sendTransaction",
    value: function sendTransaction(signedTransaction) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee24() {
        var hexTx, tx, blockNumber, hash;
        return _regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                _context24.next = 2;
                return this.getNetwork();

              case 2:
                _context24.next = 4;
                return Promise.resolve(signedTransaction).then(function (t) {
                  return hexlify(t);
                });

              case 4:
                hexTx = _context24.sent;
                tx = this.formatter.transaction(signedTransaction);

                if (tx.confirmations == null) {
                  tx.confirmations = 0;
                }

                _context24.next = 9;
                return this._getInternalBlockNumber(100 + 2 * this.pollingInterval);

              case 9:
                blockNumber = _context24.sent;
                _context24.prev = 10;
                _context24.next = 13;
                return this.perform("sendTransaction", {
                  signedTransaction: hexTx
                });

              case 13:
                hash = _context24.sent;
                return _context24.abrupt("return", this._wrapTransaction(tx, hash, blockNumber));

              case 17:
                _context24.prev = 17;
                _context24.t0 = _context24["catch"](10);
                _context24.t0.transaction = tx;
                _context24.t0.transactionHash = tx.hash;
                throw _context24.t0;

              case 22:
              case "end":
                return _context24.stop();
            }
          }
        }, _callee24, this, [[10, 17]]);
      }));
    }
  }, {
    key: "_getTransactionRequest",
    value: function _getTransactionRequest(transaction) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee25() {
        var _this13 = this;

        var values, tx;
        return _regeneratorRuntime.wrap(function _callee25$(_context25) {
          while (1) {
            switch (_context25.prev = _context25.next) {
              case 0:
                _context25.next = 2;
                return transaction;

              case 2:
                values = _context25.sent;
                tx = {};
                ["from", "to"].forEach(function (key) {
                  if (values[key] == null) {
                    return;
                  }

                  tx[key] = Promise.resolve(values[key]).then(function (v) {
                    return v ? _this13._getAddress(v) : null;
                  });
                });
                ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(function (key) {
                  if (values[key] == null) {
                    return;
                  }

                  tx[key] = Promise.resolve(values[key]).then(function (v) {
                    return v ? BigNumber.from(v) : null;
                  });
                });
                ["type"].forEach(function (key) {
                  if (values[key] == null) {
                    return;
                  }

                  tx[key] = Promise.resolve(values[key]).then(function (v) {
                    return v != null ? v : null;
                  });
                });

                if (values.accessList) {
                  tx.accessList = this.formatter.accessList(values.accessList);
                }

                ["data"].forEach(function (key) {
                  if (values[key] == null) {
                    return;
                  }

                  tx[key] = Promise.resolve(values[key]).then(function (v) {
                    return v ? hexlify(v) : null;
                  });
                });
                _context25.t0 = this.formatter;
                _context25.next = 12;
                return resolveProperties(tx);

              case 12:
                _context25.t1 = _context25.sent;
                return _context25.abrupt("return", _context25.t0.transactionRequest.call(_context25.t0, _context25.t1));

              case 14:
              case "end":
                return _context25.stop();
            }
          }
        }, _callee25, this);
      }));
    }
  }, {
    key: "_getFilter",
    value: function _getFilter(filter) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee26() {
        var _this14 = this;

        var result;
        return _regeneratorRuntime.wrap(function _callee26$(_context26) {
          while (1) {
            switch (_context26.prev = _context26.next) {
              case 0:
                _context26.next = 2;
                return filter;

              case 2:
                filter = _context26.sent;
                result = {};

                if (filter.address != null) {
                  result.address = this._getAddress(filter.address);
                }

                ["blockHash", "topics"].forEach(function (key) {
                  if (filter[key] == null) {
                    return;
                  }

                  result[key] = filter[key];
                });
                ["fromBlock", "toBlock"].forEach(function (key) {
                  if (filter[key] == null) {
                    return;
                  }

                  result[key] = _this14._getBlockTag(filter[key]);
                });
                _context26.t0 = this.formatter;
                _context26.next = 10;
                return resolveProperties(result);

              case 10:
                _context26.t1 = _context26.sent;
                return _context26.abrupt("return", _context26.t0.filter.call(_context26.t0, _context26.t1));

              case 12:
              case "end":
                return _context26.stop();
            }
          }
        }, _callee26, this);
      }));
    }
  }, {
    key: "_call",
    value: function _call(transaction, blockTag, attempt) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee27() {
        var txSender, result, data, sender, urls, urlsOffset, urlsLength, urlsData, u, url, calldata, callbackSelector, extraData, ccipResult, tx;
        return _regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                if (attempt >= MAX_CCIP_REDIRECTS) {
                  logger.throwError("CCIP read exceeded maximum redirections", Logger.errors.SERVER_ERROR, {
                    redirects: attempt,
                    transaction: transaction
                  });
                }

                txSender = transaction.to;
                _context27.next = 4;
                return this.perform("call", {
                  transaction: transaction,
                  blockTag: blockTag
                });

              case 4:
                result = _context27.sent;

                if (!(attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && hexDataLength(result) % 32 === 4)) {
                  _context27.next = 31;
                  break;
                }

                _context27.prev = 6;
                data = hexDataSlice(result, 4); // Check the sender of the OffchainLookup matches the transaction

                sender = hexDataSlice(data, 0, 32);

                if (!BigNumber.from(sender).eq(txSender)) {
                  logger.throwError("CCIP Read sender did not match", Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction: transaction,
                    data: result
                  });
                } // Read the URLs from the response


                urls = [];
                urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();
                urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();
                urlsData = hexDataSlice(data, urlsOffset + 32);

                for (u = 0; u < urlsLength; u++) {
                  url = _parseString(urlsData, u * 32);

                  if (url == null) {
                    logger.throwError("CCIP Read contained corrupt URL string", Logger.errors.CALL_EXCEPTION, {
                      name: "OffchainLookup",
                      signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                      transaction: transaction,
                      data: result
                    });
                  }

                  urls.push(url);
                } // Get the CCIP calldata to forward


                calldata = _parseBytes(data, 64); // Get the callbackSelector (bytes4)

                if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {
                  logger.throwError("CCIP Read callback selector included junk", Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction: transaction,
                    data: result
                  });
                }

                callbackSelector = hexDataSlice(data, 96, 100); // Get the extra data to send back to the contract as context

                extraData = _parseBytes(data, 128);
                _context27.next = 21;
                return this.ccipReadFetch(transaction, calldata, urls);

              case 21:
                ccipResult = _context27.sent;

                if (ccipResult == null) {
                  logger.throwError("CCIP Read disabled or provided no URLs", Logger.errors.CALL_EXCEPTION, {
                    name: "OffchainLookup",
                    signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                    transaction: transaction,
                    data: result
                  });
                }

                tx = {
                  to: txSender,
                  data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])
                };
                return _context27.abrupt("return", this._call(tx, blockTag, attempt + 1));

              case 27:
                _context27.prev = 27;
                _context27.t0 = _context27["catch"](6);

                if (!(_context27.t0.code === Logger.errors.SERVER_ERROR)) {
                  _context27.next = 31;
                  break;
                }

                throw _context27.t0;

              case 31:
                _context27.prev = 31;
                return _context27.abrupt("return", hexlify(result));

              case 35:
                _context27.prev = 35;
                _context27.t1 = _context27["catch"](31);
                return _context27.abrupt("return", logger.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                  method: "call",
                  params: {
                    transaction: transaction,
                    blockTag: blockTag
                  },
                  result: result,
                  error: _context27.t1
                }));

              case 38:
              case "end":
                return _context27.stop();
            }
          }
        }, _callee27, this, [[6, 27], [31, 35]]);
      }));
    }
  }, {
    key: "call",
    value: function call(transaction, blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee28() {
        var resolved;
        return _regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                _context28.next = 2;
                return this.getNetwork();

              case 2:
                _context28.next = 4;
                return resolveProperties({
                  transaction: this._getTransactionRequest(transaction),
                  blockTag: this._getBlockTag(blockTag),
                  ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
                });

              case 4:
                resolved = _context28.sent;
                return _context28.abrupt("return", this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1));

              case 6:
              case "end":
                return _context28.stop();
            }
          }
        }, _callee28, this);
      }));
    }
  }, {
    key: "estimateGas",
    value: function estimateGas(transaction) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee29() {
        var params, result;
        return _regeneratorRuntime.wrap(function _callee29$(_context29) {
          while (1) {
            switch (_context29.prev = _context29.next) {
              case 0:
                _context29.next = 2;
                return this.getNetwork();

              case 2:
                _context29.next = 4;
                return resolveProperties({
                  transaction: this._getTransactionRequest(transaction)
                });

              case 4:
                params = _context29.sent;
                _context29.next = 7;
                return this.perform("estimateGas", params);

              case 7:
                result = _context29.sent;
                _context29.prev = 8;
                return _context29.abrupt("return", BigNumber.from(result));

              case 12:
                _context29.prev = 12;
                _context29.t0 = _context29["catch"](8);
                return _context29.abrupt("return", logger.throwError("bad result from backend", Logger.errors.SERVER_ERROR, {
                  method: "estimateGas",
                  params: params,
                  result: result,
                  error: _context29.t0
                }));

              case 15:
              case "end":
                return _context29.stop();
            }
          }
        }, _callee29, this, [[8, 12]]);
      }));
    }
  }, {
    key: "_getAddress",
    value: function _getAddress(addressOrName) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee30() {
        var address;
        return _regeneratorRuntime.wrap(function _callee30$(_context30) {
          while (1) {
            switch (_context30.prev = _context30.next) {
              case 0:
                _context30.next = 2;
                return addressOrName;

              case 2:
                addressOrName = _context30.sent;

                if (typeof addressOrName !== "string") {
                  logger.throwArgumentError("invalid address or ENS name", "name", addressOrName);
                }

                _context30.next = 6;
                return this.resolveName(addressOrName);

              case 6:
                address = _context30.sent;

                if (address == null) {
                  logger.throwError("ENS name not configured", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "resolveName(".concat(JSON.stringify(addressOrName), ")")
                  });
                }

                return _context30.abrupt("return", address);

              case 9:
              case "end":
                return _context30.stop();
            }
          }
        }, _callee30, this);
      }));
    }
  }, {
    key: "_getBlock",
    value: function _getBlock(blockHashOrBlockTag, includeTransactions) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee32() {
        var _this15 = this;

        var blockNumber, params;
        return _regeneratorRuntime.wrap(function _callee32$(_context32) {
          while (1) {
            switch (_context32.prev = _context32.next) {
              case 0:
                _context32.next = 2;
                return this.getNetwork();

              case 2:
                _context32.next = 4;
                return blockHashOrBlockTag;

              case 4:
                blockHashOrBlockTag = _context32.sent;
                // If blockTag is a number (not "latest", etc), this is the block number
                blockNumber = -128;
                params = {
                  includeTransactions: !!includeTransactions
                };

                if (!isHexString(blockHashOrBlockTag, 32)) {
                  _context32.next = 11;
                  break;
                }

                params.blockHash = blockHashOrBlockTag;
                _context32.next = 21;
                break;

              case 11:
                _context32.prev = 11;
                _context32.next = 14;
                return this._getBlockTag(blockHashOrBlockTag);

              case 14:
                params.blockTag = _context32.sent;

                if (isHexString(params.blockTag)) {
                  blockNumber = parseInt(params.blockTag.substring(2), 16);
                }

                _context32.next = 21;
                break;

              case 18:
                _context32.prev = 18;
                _context32.t0 = _context32["catch"](11);
                logger.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);

              case 21:
                return _context32.abrupt("return", poll(function () {
                  return __awaiter(_this15, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee31() {
                    var _this16 = this;

                    var block, _blockNumber, i, tx, confirmations, blockWithTxs;

                    return _regeneratorRuntime.wrap(function _callee31$(_context31) {
                      while (1) {
                        switch (_context31.prev = _context31.next) {
                          case 0:
                            _context31.next = 2;
                            return this.perform("getBlock", params);

                          case 2:
                            block = _context31.sent;

                            if (!(block == null)) {
                              _context31.next = 11;
                              break;
                            }

                            if (!(params.blockHash != null)) {
                              _context31.next = 7;
                              break;
                            }

                            if (!(this._emitted["b:" + params.blockHash] == null)) {
                              _context31.next = 7;
                              break;
                            }

                            return _context31.abrupt("return", null);

                          case 7:
                            if (!(params.blockTag != null)) {
                              _context31.next = 10;
                              break;
                            }

                            if (!(blockNumber > this._emitted.block)) {
                              _context31.next = 10;
                              break;
                            }

                            return _context31.abrupt("return", null);

                          case 10:
                            return _context31.abrupt("return", undefined);

                          case 11:
                            if (!includeTransactions) {
                              _context31.next = 34;
                              break;
                            }

                            _blockNumber = null;
                            i = 0;

                          case 14:
                            if (!(i < block.transactions.length)) {
                              _context31.next = 31;
                              break;
                            }

                            tx = block.transactions[i];

                            if (!(tx.blockNumber == null)) {
                              _context31.next = 20;
                              break;
                            }

                            tx.confirmations = 0;
                            _context31.next = 28;
                            break;

                          case 20:
                            if (!(tx.confirmations == null)) {
                              _context31.next = 28;
                              break;
                            }

                            if (!(_blockNumber == null)) {
                              _context31.next = 25;
                              break;
                            }

                            _context31.next = 24;
                            return this._getInternalBlockNumber(100 + 2 * this.pollingInterval);

                          case 24:
                            _blockNumber = _context31.sent;

                          case 25:
                            // Add the confirmations using the fast block number (pessimistic)
                            confirmations = _blockNumber - tx.blockNumber + 1;

                            if (confirmations <= 0) {
                              confirmations = 1;
                            }

                            tx.confirmations = confirmations;

                          case 28:
                            i++;
                            _context31.next = 14;
                            break;

                          case 31:
                            blockWithTxs = this.formatter.blockWithTransactions(block);
                            blockWithTxs.transactions = blockWithTxs.transactions.map(function (tx) {
                              return _this16._wrapTransaction(tx);
                            });
                            return _context31.abrupt("return", blockWithTxs);

                          case 34:
                            return _context31.abrupt("return", this.formatter.block(block));

                          case 35:
                          case "end":
                            return _context31.stop();
                        }
                      }
                    }, _callee31, this);
                  }));
                }, {
                  oncePoll: this
                }));

              case 22:
              case "end":
                return _context32.stop();
            }
          }
        }, _callee32, this, [[11, 18]]);
      }));
    }
  }, {
    key: "getBlock",
    value: function getBlock(blockHashOrBlockTag) {
      return this._getBlock(blockHashOrBlockTag, false);
    }
  }, {
    key: "getBlockWithTransactions",
    value: function getBlockWithTransactions(blockHashOrBlockTag) {
      return this._getBlock(blockHashOrBlockTag, true);
    }
  }, {
    key: "getTransaction",
    value: function getTransaction(transactionHash) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee34() {
        var _this17 = this;

        var params;
        return _regeneratorRuntime.wrap(function _callee34$(_context34) {
          while (1) {
            switch (_context34.prev = _context34.next) {
              case 0:
                _context34.next = 2;
                return this.getNetwork();

              case 2:
                _context34.next = 4;
                return transactionHash;

              case 4:
                transactionHash = _context34.sent;
                params = {
                  transactionHash: this.formatter.hash(transactionHash, true)
                };
                return _context34.abrupt("return", poll(function () {
                  return __awaiter(_this17, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee33() {
                    var result, tx, blockNumber, confirmations;
                    return _regeneratorRuntime.wrap(function _callee33$(_context33) {
                      while (1) {
                        switch (_context33.prev = _context33.next) {
                          case 0:
                            _context33.next = 2;
                            return this.perform("getTransaction", params);

                          case 2:
                            result = _context33.sent;

                            if (!(result == null)) {
                              _context33.next = 7;
                              break;
                            }

                            if (!(this._emitted["t:" + transactionHash] == null)) {
                              _context33.next = 6;
                              break;
                            }

                            return _context33.abrupt("return", null);

                          case 6:
                            return _context33.abrupt("return", undefined);

                          case 7:
                            tx = this.formatter.transactionResponse(result);

                            if (!(tx.blockNumber == null)) {
                              _context33.next = 12;
                              break;
                            }

                            tx.confirmations = 0;
                            _context33.next = 19;
                            break;

                          case 12:
                            if (!(tx.confirmations == null)) {
                              _context33.next = 19;
                              break;
                            }

                            _context33.next = 15;
                            return this._getInternalBlockNumber(100 + 2 * this.pollingInterval);

                          case 15:
                            blockNumber = _context33.sent;
                            // Add the confirmations using the fast block number (pessimistic)
                            confirmations = blockNumber - tx.blockNumber + 1;

                            if (confirmations <= 0) {
                              confirmations = 1;
                            }

                            tx.confirmations = confirmations;

                          case 19:
                            return _context33.abrupt("return", this._wrapTransaction(tx));

                          case 20:
                          case "end":
                            return _context33.stop();
                        }
                      }
                    }, _callee33, this);
                  }));
                }, {
                  oncePoll: this
                }));

              case 7:
              case "end":
                return _context34.stop();
            }
          }
        }, _callee34, this);
      }));
    }
  }, {
    key: "getTransactionReceipt",
    value: function getTransactionReceipt(transactionHash) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee36() {
        var _this18 = this;

        var params;
        return _regeneratorRuntime.wrap(function _callee36$(_context36) {
          while (1) {
            switch (_context36.prev = _context36.next) {
              case 0:
                _context36.next = 2;
                return this.getNetwork();

              case 2:
                _context36.next = 4;
                return transactionHash;

              case 4:
                transactionHash = _context36.sent;
                params = {
                  transactionHash: this.formatter.hash(transactionHash, true)
                };
                return _context36.abrupt("return", poll(function () {
                  return __awaiter(_this18, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee35() {
                    var result, receipt, blockNumber, confirmations;
                    return _regeneratorRuntime.wrap(function _callee35$(_context35) {
                      while (1) {
                        switch (_context35.prev = _context35.next) {
                          case 0:
                            _context35.next = 2;
                            return this.perform("getTransactionReceipt", params);

                          case 2:
                            result = _context35.sent;

                            if (!(result == null)) {
                              _context35.next = 7;
                              break;
                            }

                            if (!(this._emitted["t:" + transactionHash] == null)) {
                              _context35.next = 6;
                              break;
                            }

                            return _context35.abrupt("return", null);

                          case 6:
                            return _context35.abrupt("return", undefined);

                          case 7:
                            if (!(result.blockHash == null)) {
                              _context35.next = 9;
                              break;
                            }

                            return _context35.abrupt("return", undefined);

                          case 9:
                            receipt = this.formatter.receipt(result);

                            if (!(receipt.blockNumber == null)) {
                              _context35.next = 14;
                              break;
                            }

                            receipt.confirmations = 0;
                            _context35.next = 21;
                            break;

                          case 14:
                            if (!(receipt.confirmations == null)) {
                              _context35.next = 21;
                              break;
                            }

                            _context35.next = 17;
                            return this._getInternalBlockNumber(100 + 2 * this.pollingInterval);

                          case 17:
                            blockNumber = _context35.sent;
                            // Add the confirmations using the fast block number (pessimistic)
                            confirmations = blockNumber - receipt.blockNumber + 1;

                            if (confirmations <= 0) {
                              confirmations = 1;
                            }

                            receipt.confirmations = confirmations;

                          case 21:
                            return _context35.abrupt("return", receipt);

                          case 22:
                          case "end":
                            return _context35.stop();
                        }
                      }
                    }, _callee35, this);
                  }));
                }, {
                  oncePoll: this
                }));

              case 7:
              case "end":
                return _context36.stop();
            }
          }
        }, _callee36, this);
      }));
    }
  }, {
    key: "getLogs",
    value: function getLogs(filter) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee37() {
        var params, logs;
        return _regeneratorRuntime.wrap(function _callee37$(_context37) {
          while (1) {
            switch (_context37.prev = _context37.next) {
              case 0:
                _context37.next = 2;
                return this.getNetwork();

              case 2:
                _context37.next = 4;
                return resolveProperties({
                  filter: this._getFilter(filter)
                });

              case 4:
                params = _context37.sent;
                _context37.next = 7;
                return this.perform("getLogs", params);

              case 7:
                logs = _context37.sent;
                logs.forEach(function (log) {
                  if (log.removed == null) {
                    log.removed = false;
                  }
                });
                return _context37.abrupt("return", Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs));

              case 10:
              case "end":
                return _context37.stop();
            }
          }
        }, _callee37, this);
      }));
    }
  }, {
    key: "getEtherPrice",
    value: function getEtherPrice() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee38() {
        return _regeneratorRuntime.wrap(function _callee38$(_context38) {
          while (1) {
            switch (_context38.prev = _context38.next) {
              case 0:
                _context38.next = 2;
                return this.getNetwork();

              case 2:
                return _context38.abrupt("return", this.perform("getEtherPrice", {}));

              case 3:
              case "end":
                return _context38.stop();
            }
          }
        }, _callee38, this);
      }));
    }
  }, {
    key: "_getBlockTag",
    value: function _getBlockTag(blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee39() {
        var blockNumber;
        return _regeneratorRuntime.wrap(function _callee39$(_context39) {
          while (1) {
            switch (_context39.prev = _context39.next) {
              case 0:
                _context39.next = 2;
                return blockTag;

              case 2:
                blockTag = _context39.sent;

                if (!(typeof blockTag === "number" && blockTag < 0)) {
                  _context39.next = 11;
                  break;
                }

                if (blockTag % 1) {
                  logger.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
                }

                _context39.next = 7;
                return this._getInternalBlockNumber(100 + 2 * this.pollingInterval);

              case 7:
                blockNumber = _context39.sent;
                blockNumber += blockTag;

                if (blockNumber < 0) {
                  blockNumber = 0;
                }

                return _context39.abrupt("return", this.formatter.blockTag(blockNumber));

              case 11:
                return _context39.abrupt("return", this.formatter.blockTag(blockTag));

              case 12:
              case "end":
                return _context39.stop();
            }
          }
        }, _callee39, this);
      }));
    }
  }, {
    key: "getResolver",
    value: function getResolver(name) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee40() {
        var currentName, addr, resolver;
        return _regeneratorRuntime.wrap(function _callee40$(_context40) {
          while (1) {
            switch (_context40.prev = _context40.next) {
              case 0:
                currentName = name;

              case 1:
                if (!true) {
                  _context40.next = 22;
                  break;
                }

                if (!(currentName === "" || currentName === ".")) {
                  _context40.next = 4;
                  break;
                }

                return _context40.abrupt("return", null);

              case 4:
                if (!(name !== "eth" && currentName === "eth")) {
                  _context40.next = 6;
                  break;
                }

                return _context40.abrupt("return", null);

              case 6:
                _context40.next = 8;
                return this._getResolver(currentName, "getResolver");

              case 8:
                addr = _context40.sent;

                if (!(addr != null)) {
                  _context40.next = 19;
                  break;
                }

                resolver = new Resolver(this, addr, name); // Legacy resolver found, using EIP-2544 so it isn't safe to use

                _context40.t0 = currentName !== name;

                if (!_context40.t0) {
                  _context40.next = 16;
                  break;
                }

                _context40.next = 15;
                return resolver.supportsWildcard();

              case 15:
                _context40.t0 = !_context40.sent;

              case 16:
                if (!_context40.t0) {
                  _context40.next = 18;
                  break;
                }

                return _context40.abrupt("return", null);

              case 18:
                return _context40.abrupt("return", resolver);

              case 19:
                // Get the parent node
                currentName = currentName.split(".").slice(1).join(".");
                _context40.next = 1;
                break;

              case 22:
              case "end":
                return _context40.stop();
            }
          }
        }, _callee40, this);
      }));
    }
  }, {
    key: "_getResolver",
    value: function _getResolver(name, operation) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee41() {
        var network, addrData;
        return _regeneratorRuntime.wrap(function _callee41$(_context41) {
          while (1) {
            switch (_context41.prev = _context41.next) {
              case 0:
                if (operation == null) {
                  operation = "ENS";
                }

                _context41.next = 3;
                return this.getNetwork();

              case 3:
                network = _context41.sent;

                // No ENS...
                if (!network.ensAddress) {
                  logger.throwError("network does not support ENS", Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: operation,
                    network: network.name
                  });
                }

                _context41.prev = 5;
                _context41.next = 8;
                return this.call({
                  to: network.ensAddress,
                  data: "0x0178b8bf" + namehash(name).substring(2)
                });

              case 8:
                addrData = _context41.sent;
                return _context41.abrupt("return", this.formatter.callAddress(addrData));

              case 12:
                _context41.prev = 12;
                _context41.t0 = _context41["catch"](5);

              case 14:
                return _context41.abrupt("return", null);

              case 15:
              case "end":
                return _context41.stop();
            }
          }
        }, _callee41, this, [[5, 12]]);
      }));
    }
  }, {
    key: "resolveName",
    value: function resolveName(name) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee42() {
        var resolver;
        return _regeneratorRuntime.wrap(function _callee42$(_context42) {
          while (1) {
            switch (_context42.prev = _context42.next) {
              case 0:
                _context42.next = 2;
                return name;

              case 2:
                name = _context42.sent;
                _context42.prev = 3;
                return _context42.abrupt("return", Promise.resolve(this.formatter.address(name)));

              case 7:
                _context42.prev = 7;
                _context42.t0 = _context42["catch"](3);

                if (!isHexString(name)) {
                  _context42.next = 11;
                  break;
                }

                throw _context42.t0;

              case 11:
                if (typeof name !== "string") {
                  logger.throwArgumentError("invalid ENS name", "name", name);
                } // Get the addr from the resovler


                _context42.next = 14;
                return this.getResolver(name);

              case 14:
                resolver = _context42.sent;

                if (resolver) {
                  _context42.next = 17;
                  break;
                }

                return _context42.abrupt("return", null);

              case 17:
                _context42.next = 19;
                return resolver.getAddress();

              case 19:
                return _context42.abrupt("return", _context42.sent);

              case 20:
              case "end":
                return _context42.stop();
            }
          }
        }, _callee42, this, [[3, 7]]);
      }));
    }
  }, {
    key: "lookupAddress",
    value: function lookupAddress(address) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee43() {
        var node, resolverAddr, name, addr;
        return _regeneratorRuntime.wrap(function _callee43$(_context43) {
          while (1) {
            switch (_context43.prev = _context43.next) {
              case 0:
                _context43.next = 2;
                return address;

              case 2:
                address = _context43.sent;
                address = this.formatter.address(address);
                node = address.substring(2).toLowerCase() + ".addr.reverse";
                _context43.next = 7;
                return this._getResolver(node, "lookupAddress");

              case 7:
                resolverAddr = _context43.sent;

                if (!(resolverAddr == null)) {
                  _context43.next = 10;
                  break;
                }

                return _context43.abrupt("return", null);

              case 10:
                _context43.t0 = _parseString;
                _context43.next = 13;
                return this.call({
                  to: resolverAddr,
                  data: "0x691f3431" + namehash(node).substring(2)
                });

              case 13:
                _context43.t1 = _context43.sent;
                name = (0, _context43.t0)(_context43.t1, 0);
                _context43.next = 17;
                return this.resolveName(name);

              case 17:
                addr = _context43.sent;

                if (!(addr != address)) {
                  _context43.next = 20;
                  break;
                }

                return _context43.abrupt("return", null);

              case 20:
                return _context43.abrupt("return", name);

              case 21:
              case "end":
                return _context43.stop();
            }
          }
        }, _callee43, this);
      }));
    }
  }, {
    key: "getAvatar",
    value: function getAvatar(nameOrAddress) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee44() {
        var resolver, address, node, resolverAddress, _avatar, name, avatar;

        return _regeneratorRuntime.wrap(function _callee44$(_context44) {
          while (1) {
            switch (_context44.prev = _context44.next) {
              case 0:
                resolver = null;

                if (!isHexString(nameOrAddress)) {
                  _context44.next = 40;
                  break;
                }

                // Address; reverse lookup
                address = this.formatter.address(nameOrAddress);
                node = address.substring(2).toLowerCase() + ".addr.reverse";
                _context44.next = 6;
                return this._getResolver(node, "getAvatar");

              case 6:
                resolverAddress = _context44.sent;

                if (resolverAddress) {
                  _context44.next = 9;
                  break;
                }

                return _context44.abrupt("return", null);

              case 9:
                // Try resolving the avatar against the addr.reverse resolver
                resolver = new Resolver(this, resolverAddress, node);
                _context44.prev = 10;
                _context44.next = 13;
                return resolver.getAvatar();

              case 13:
                _avatar = _context44.sent;

                if (!_avatar) {
                  _context44.next = 16;
                  break;
                }

                return _context44.abrupt("return", _avatar.url);

              case 16:
                _context44.next = 22;
                break;

              case 18:
                _context44.prev = 18;
                _context44.t0 = _context44["catch"](10);

                if (!(_context44.t0.code !== Logger.errors.CALL_EXCEPTION)) {
                  _context44.next = 22;
                  break;
                }

                throw _context44.t0;

              case 22:
                _context44.prev = 22;
                _context44.t1 = _parseString;
                _context44.next = 26;
                return this.call({
                  to: resolverAddress,
                  data: "0x691f3431" + namehash(node).substring(2)
                });

              case 26:
                _context44.t2 = _context44.sent;
                name = (0, _context44.t1)(_context44.t2, 0);
                _context44.next = 30;
                return this.getResolver(name);

              case 30:
                resolver = _context44.sent;
                _context44.next = 38;
                break;

              case 33:
                _context44.prev = 33;
                _context44.t3 = _context44["catch"](22);

                if (!(_context44.t3.code !== Logger.errors.CALL_EXCEPTION)) {
                  _context44.next = 37;
                  break;
                }

                throw _context44.t3;

              case 37:
                return _context44.abrupt("return", null);

              case 38:
                _context44.next = 45;
                break;

              case 40:
                _context44.next = 42;
                return this.getResolver(nameOrAddress);

              case 42:
                resolver = _context44.sent;

                if (resolver) {
                  _context44.next = 45;
                  break;
                }

                return _context44.abrupt("return", null);

              case 45:
                _context44.next = 47;
                return resolver.getAvatar();

              case 47:
                avatar = _context44.sent;

                if (!(avatar == null)) {
                  _context44.next = 50;
                  break;
                }

                return _context44.abrupt("return", null);

              case 50:
                return _context44.abrupt("return", avatar.url);

              case 51:
              case "end":
                return _context44.stop();
            }
          }
        }, _callee44, this, [[10, 18], [22, 33]]);
      }));
    }
  }, {
    key: "perform",
    value: function perform(method, params) {
      return logger.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, {
        operation: method
      });
    }
  }, {
    key: "_startEvent",
    value: function _startEvent(event) {
      this.polling = this._events.filter(function (e) {
        return e.pollable();
      }).length > 0;
    }
  }, {
    key: "_stopEvent",
    value: function _stopEvent(event) {
      this.polling = this._events.filter(function (e) {
        return e.pollable();
      }).length > 0;
    }
  }, {
    key: "_addEventListener",
    value: function _addEventListener(eventName, listener, once) {
      var event = new Event(getEventTag(eventName), listener, once);

      this._events.push(event);

      this._startEvent(event);

      return this;
    }
  }, {
    key: "on",
    value: function on(eventName, listener) {
      return this._addEventListener(eventName, listener, false);
    }
  }, {
    key: "once",
    value: function once(eventName, listener) {
      return this._addEventListener(eventName, listener, true);
    }
  }, {
    key: "emit",
    value: function emit(eventName) {
      var _this19 = this;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var result = false;
      var stopped = [];
      var eventTag = getEventTag(eventName);
      this._events = this._events.filter(function (event) {
        if (event.tag !== eventTag) {
          return true;
        }

        setTimeout(function () {
          event.listener.apply(_this19, args);
        }, 0);
        result = true;

        if (event.once) {
          stopped.push(event);
          return false;
        }

        return true;
      });
      stopped.forEach(function (event) {
        _this19._stopEvent(event);
      });
      return result;
    }
  }, {
    key: "listenerCount",
    value: function listenerCount(eventName) {
      if (!eventName) {
        return this._events.length;
      }

      var eventTag = getEventTag(eventName);
      return this._events.filter(function (event) {
        return event.tag === eventTag;
      }).length;
    }
  }, {
    key: "listeners",
    value: function listeners(eventName) {
      if (eventName == null) {
        return this._events.map(function (event) {
          return event.listener;
        });
      }

      var eventTag = getEventTag(eventName);
      return this._events.filter(function (event) {
        return event.tag === eventTag;
      }).map(function (event) {
        return event.listener;
      });
    }
  }, {
    key: "off",
    value: function off(eventName, listener) {
      var _this20 = this;

      if (listener == null) {
        return this.removeAllListeners(eventName);
      }

      var stopped = [];
      var found = false;
      var eventTag = getEventTag(eventName);
      this._events = this._events.filter(function (event) {
        if (event.tag !== eventTag || event.listener != listener) {
          return true;
        }

        if (found) {
          return true;
        }

        found = true;
        stopped.push(event);
        return false;
      });
      stopped.forEach(function (event) {
        _this20._stopEvent(event);
      });
      return this;
    }
  }, {
    key: "removeAllListeners",
    value: function removeAllListeners(eventName) {
      var _this21 = this;

      var stopped = [];

      if (eventName == null) {
        stopped = this._events;
        this._events = [];
      } else {
        var eventTag = getEventTag(eventName);
        this._events = this._events.filter(function (event) {
          if (event.tag !== eventTag) {
            return true;
          }

          stopped.push(event);
          return false;
        });
      }

      stopped.forEach(function (event) {
        _this21._stopEvent(event);
      });
      return this;
    }
  }], [{
    key: "getFormatter",
    value: function getFormatter() {
      if (defaultFormatter == null) {
        defaultFormatter = new Formatter();
      }

      return defaultFormatter;
    } // @TODO: Remove this and just use getNetwork

  }, {
    key: "getNetwork",
    value: function getNetwork(network) {
      return _getNetwork(network == null ? "homestead" : network);
    }
  }]);

  return BaseProvider;
}(Provider);