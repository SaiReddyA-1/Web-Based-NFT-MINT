"use strict";

import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";
import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _assertThisInitialized from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/assertThisInitialized";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _get from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/get";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { BigNumber } from "@ethersproject/bignumber";
import { defineReadOnly } from "@ethersproject/properties";
import { JsonRpcProvider } from "./json-rpc-provider";
import { WebSocket } from "./ws";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */

var NextId = 1; // For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub

export var WebSocketProvider = /*#__PURE__*/function (_JsonRpcProvider) {
  _inherits(WebSocketProvider, _JsonRpcProvider);

  var _super = _createSuper(WebSocketProvider);

  function WebSocketProvider(url, network) {
    var _thisSuper, _this;

    _classCallCheck(this, WebSocketProvider);

    // This will be added in the future; please open an issue to expedite
    if (network === "any") {
      logger.throwError("WebSocketProvider does not support 'any' network yet", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }

    if (typeof url === "string") {
      _this = _super.call(this, url, network);
    } else {
      _this = _super.call(this, "_websocket", network);
    }

    _this._pollingInterval = -1;
    _this._wsReady = false;

    if (typeof url === "string") {
      defineReadOnly(_assertThisInitialized(_this), "_websocket", new WebSocket(_this.connection.url));
    } else {
      defineReadOnly(_assertThisInitialized(_this), "_websocket", url);
    }

    defineReadOnly(_assertThisInitialized(_this), "_requests", {});
    defineReadOnly(_assertThisInitialized(_this), "_subs", {});
    defineReadOnly(_assertThisInitialized(_this), "_subIds", {});
    defineReadOnly(_assertThisInitialized(_this), "_detectNetwork", _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(WebSocketProvider.prototype)), "detectNetwork", _thisSuper).call(_thisSuper)); // Stall sending requests until the socket is open...

    _this.websocket.onopen = function () {
      _this._wsReady = true;
      Object.keys(_this._requests).forEach(function (id) {
        _this.websocket.send(_this._requests[id].payload);
      });
    };

    _this.websocket.onmessage = function (messageEvent) {
      var data = messageEvent.data;
      var result = JSON.parse(data);

      if (result.id != null) {
        var id = String(result.id);
        var request = _this._requests[id];
        delete _this._requests[id];

        if (result.result !== undefined) {
          request.callback(null, result.result);

          _this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: _assertThisInitialized(_this)
          });
        } else {
          var error = null;

          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            defineReadOnly(error, "code", result.error.code || null);
            defineReadOnly(error, "response", data);
          } else {
            error = new Error("unknown error");
          }

          request.callback(error, undefined);

          _this.emit("debug", {
            action: "response",
            error: error,
            request: JSON.parse(request.payload),
            provider: _assertThisInitialized(_this)
          });
        }
      } else if (result.method === "eth_subscription") {
        // Subscription...
        var sub = _this._subs[result.params.subscription];

        if (sub) {
          //this.emit.apply(this,                  );
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    }; // This Provider does not actually poll, but we want to trigger
    // poll events for things that depend on them (like stalling for
    // block and transaction lookups)


    var fauxPoll = setInterval(function () {
      _this.emit("poll");
    }, 1000);

    if (fauxPoll.unref) {
      fauxPoll.unref();
    }

    return _possibleConstructorReturn(_this);
  } // Cannot narrow the type of _websocket, as that is not backwards compatible
  // so we add a getter and let the WebSocket be a public API.


  _createClass(WebSocketProvider, [{
    key: "websocket",
    get: function get() {
      return this._websocket;
    }
  }, {
    key: "detectNetwork",
    value: function detectNetwork() {
      return this._detectNetwork;
    }
  }, {
    key: "pollingInterval",
    get: function get() {
      return 0;
    },
    set: function set(value) {
      logger.throwError("cannot set polling interval on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setPollingInterval"
      });
    }
  }, {
    key: "resetEventsBlock",
    value: function resetEventsBlock(blockNumber) {
      logger.throwError("cannot reset events block on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resetEventBlock"
      });
    }
  }, {
    key: "poll",
    value: function poll() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                return _context.abrupt("return", null);

              case 1:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
    }
  }, {
    key: "polling",
    set: function set(value) {
      if (!value) {
        return;
      }

      logger.throwError("cannot set polling on WebSocketProvider", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setPolling"
      });
    }
  }, {
    key: "send",
    value: function send(method, params) {
      var _this2 = this;

      var rid = NextId++;
      return new Promise(function (resolve, reject) {
        function callback(error, result) {
          if (error) {
            return reject(error);
          }

          return resolve(result);
        }

        var payload = JSON.stringify({
          method: method,
          params: params,
          id: rid,
          jsonrpc: "2.0"
        });

        _this2.emit("debug", {
          action: "request",
          request: JSON.parse(payload),
          provider: _this2
        });

        _this2._requests[String(rid)] = {
          callback: callback,
          payload: payload
        };

        if (_this2._wsReady) {
          _this2.websocket.send(payload);
        }
      });
    }
  }, {
    key: "_subscribe",
    value: function _subscribe(tag, param, processFunc) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this3 = this;

        var subIdPromise, subId;
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                subIdPromise = this._subIds[tag];

                if (subIdPromise == null) {
                  subIdPromise = Promise.all(param).then(function (param) {
                    return _this3.send("eth_subscribe", param);
                  });
                  this._subIds[tag] = subIdPromise;
                }

                _context2.next = 4;
                return subIdPromise;

              case 4:
                subId = _context2.sent;
                this._subs[subId] = {
                  tag: tag,
                  processFunc: processFunc
                };

              case 6:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "_startEvent",
    value: function _startEvent(event) {
      var _this4 = this;

      switch (event.type) {
        case "block":
          this._subscribe("block", ["newHeads"], function (result) {
            var blockNumber = BigNumber.from(result.number).toNumber();
            _this4._emitted.block = blockNumber;

            _this4.emit("block", blockNumber);
          });

          break;

        case "pending":
          this._subscribe("pending", ["newPendingTransactions"], function (result) {
            _this4.emit("pending", result);
          });

          break;

        case "filter":
          this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], function (result) {
            if (result.removed == null) {
              result.removed = false;
            }

            _this4.emit(event.filter, _this4.formatter.filterLog(result));
          });

          break;

        case "tx":
          {
            var emitReceipt = function emitReceipt(event) {
              var hash = event.hash;

              _this4.getTransactionReceipt(hash).then(function (receipt) {
                if (!receipt) {
                  return;
                }

                _this4.emit(hash, receipt);
              });
            }; // In case it is already mined


            emitReceipt(event); // To keep things simple, we start up a single newHeads subscription
            // to keep an eye out for transactions we are watching for.
            // Starting a subscription for an event (i.e. "tx") that is already
            // running is (basically) a nop.

            this._subscribe("tx", ["newHeads"], function (result) {
              _this4._events.filter(function (e) {
                return e.type === "tx";
              }).forEach(emitReceipt);
            });

            break;
          }
        // Nothing is needed

        case "debug":
        case "poll":
        case "willPoll":
        case "didPoll":
        case "error":
          break;

        default:
          console.log("unhandled:", event);
          break;
      }
    }
  }, {
    key: "_stopEvent",
    value: function _stopEvent(event) {
      var _this5 = this;

      var tag = event.tag;

      if (event.type === "tx") {
        // There are remaining transaction event listeners
        if (this._events.filter(function (e) {
          return e.type === "tx";
        }).length) {
          return;
        }

        tag = "tx";
      } else if (this.listenerCount(event.event)) {
        // There are remaining event listeners
        return;
      }

      var subId = this._subIds[tag];

      if (!subId) {
        return;
      }

      delete this._subIds[tag];
      subId.then(function (subId) {
        if (!_this5._subs[subId]) {
          return;
        }

        delete _this5._subs[subId];

        _this5.send("eth_unsubscribe", [subId]);
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this6 = this;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(this.websocket.readyState === WebSocket.CONNECTING)) {
                  _context3.next = 3;
                  break;
                }

                _context3.next = 3;
                return new Promise(function (resolve) {
                  _this6.websocket.onopen = function () {
                    resolve(true);
                  };

                  _this6.websocket.onerror = function () {
                    resolve(false);
                  };
                });

              case 3:
                // Hangup
                // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
                this.websocket.close(1000);

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
    }
  }], [{
    key: "defaultUrl",
    value: function defaultUrl() {
      return "ws:/\/localhost:8546";
    }
  }]);

  return WebSocketProvider;
}(JsonRpcProvider);