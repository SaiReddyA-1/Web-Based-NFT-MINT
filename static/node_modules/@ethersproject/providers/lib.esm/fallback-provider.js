"use strict";

import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _assertThisInitialized from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/assertThisInitialized";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";
import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { Provider } from "@ethersproject/abstract-provider";
import { BigNumber } from "@ethersproject/bignumber";
import { isHexString } from "@ethersproject/bytes";
import { deepCopy, defineReadOnly, shallowCopy } from "@ethersproject/properties";
import { shuffled } from "@ethersproject/random";
import { poll } from "@ethersproject/web";
import { BaseProvider } from "./base-provider";
import { isCommunityResource } from "./formatter";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);

function now() {
  return new Date().getTime();
} // Returns to network as long as all agree, or null if any is null.
// Throws an error if any two networks do not match.


function checkNetworks(networks) {
  var result = null;

  for (var i = 0; i < networks.length; i++) {
    var network = networks[i]; // Null! We do not know our network; bail.

    if (network == null) {
      return null;
    }

    if (result) {
      // Make sure the network matches the previous networks
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger.throwArgumentError("provider mismatch", "networks", networks);
      }
    } else {
      result = network;
    }
  }

  return result;
}

function median(values, maxDelta) {
  values = values.slice().sort();
  var middle = Math.floor(values.length / 2); // Odd length; take the middle

  if (values.length % 2) {
    return values[middle];
  } // Even length; take the average of the two middle


  var a = values[middle - 1],
      b = values[middle];

  if (maxDelta != null && Math.abs(a - b) > maxDelta) {
    return null;
  }

  return (a + b) / 2;
}

function serialize(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map(function (i) {
      return serialize(i);
    }));
  } else if (typeof value === "object") {
    var keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map(function (key) {
      var v = value[key];

      if (typeof v === "function") {
        v = "[function]";
      } else {
        v = serialize(v);
      }

      return JSON.stringify(key) + ":" + v;
    }).join(",") + "}";
  }

  throw new Error("unknown value type: " + typeof value);
} // Next request ID to use for emitting debug info


var nextRid = 1;
;

function stall(duration) {
  var cancel = null;
  var timer = null;
  var promise = new Promise(function (resolve) {
    cancel = function cancel() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      resolve();
    };

    timer = setTimeout(cancel, duration);
  });

  var wait = function wait(func) {
    promise = promise.then(func);
    return promise;
  };

  function getPromise() {
    return promise;
  }

  return {
    cancel: cancel,
    getPromise: getPromise,
    wait: wait
  };
}

var ForwardErrors = [Logger.errors.CALL_EXCEPTION, Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED, Logger.errors.UNPREDICTABLE_GAS_LIMIT];
var ForwardProperties = ["address", "args", "errorArgs", "errorSignature", "method", "transaction"];
;

function exposeDebugConfig(config, now) {
  var result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", {
    get: function get() {
      return config.provider;
    }
  });

  if (config.start) {
    result.start = config.start;
  }

  if (now) {
    result.duration = now - config.start;
  }

  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }

  return result;
}

function normalizedTally(normalize, quorum) {
  return function (configs) {
    // Count the votes for each result
    var tally = {};
    configs.forEach(function (c) {
      var value = normalize(c.result);

      if (!tally[value]) {
        tally[value] = {
          count: 0,
          result: c.result
        };
      }

      tally[value].count++;
    }); // Check for a quorum on any given result

    var keys = Object.keys(tally);

    for (var i = 0; i < keys.length; i++) {
      var check = tally[keys[i]];

      if (check.count >= quorum) {
        return check.result;
      }
    } // No quroum


    return undefined;
  };
}

function getProcessFunc(provider, method, params) {
  var normalize = serialize;

  switch (method) {
    case "getBlockNumber":
      // Return the median value, unless there is (median + 1) is also
      // present, in which case that is probably true and the median
      // is going to be stale soon. In the event of a malicious node,
      // the lie will be true soon enough.
      return function (configs) {
        var values = configs.map(function (c) {
          return c.result;
        }); // Get the median block number

        var blockNumber = median(configs.map(function (c) {
          return c.result;
        }), 2);

        if (blockNumber == null) {
          return undefined;
        }

        blockNumber = Math.ceil(blockNumber); // If the next block height is present, its prolly safe to use

        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        } // Don't ever roll back the blockNumber


        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }

        return provider._highestBlockNumber;
      };

    case "getGasPrice":
      // Return the middle (round index up) value, similar to median
      // but do not average even entries and choose the higher.
      // Malicious actors must compromise 50% of the nodes to lie.
      return function (configs) {
        var values = configs.map(function (c) {
          return c.result;
        });
        values.sort();
        return values[Math.floor(values.length / 2)];
      };

    case "getEtherPrice":
      // Returns the median price. Malicious actors must compromise at
      // least 50% of the nodes to lie (in a meaningful way).
      return function (configs) {
        return median(configs.map(function (c) {
          return c.result;
        }));
      };
    // No additional normalizing required; serialize is enough

    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    // We drop the confirmations from transactions as it is approximate

    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function normalize(tx) {
        if (tx == null) {
          return null;
        }

        tx = shallowCopy(tx);
        tx.confirmations = -1;
        return serialize(tx);
      };

      break;
    // We drop the confirmations from transactions as it is approximate

    case "getBlock":
      // We drop the confirmations from transactions as it is approximate
      if (params.includeTransactions) {
        normalize = function normalize(block) {
          if (block == null) {
            return null;
          }

          block = shallowCopy(block);
          block.transactions = block.transactions.map(function (tx) {
            tx = shallowCopy(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize(block);
        };
      } else {
        normalize = function normalize(block) {
          if (block == null) {
            return null;
          }

          return serialize(block);
        };
      }

      break;

    default:
      throw new Error("unknown method: " + method);
  } // Return the result if and only if the expected quorum is
  // satisfied and agreed upon for the final result.


  return normalizedTally(normalize, provider.quorum);
} // If we are doing a blockTag query, we need to make sure the backend is
// caught up to the FallbackProvider, before sending a request to it.


function waitForSync(config, blockNumber) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var provider;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            provider = config.provider;

            if (!(provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1)) {
              _context.next = 3;
              break;
            }

            return _context.abrupt("return", provider);

          case 3:
            return _context.abrupt("return", poll(function () {
              return new Promise(function (resolve, reject) {
                setTimeout(function () {
                  // We are synced
                  if (provider.blockNumber >= blockNumber) {
                    return resolve(provider);
                  } // We're done; just quit


                  // We're done; just quit
                  if (config.cancelled) {
                    return resolve(null);
                  } // Try again, next block


                  // Try again, next block
                  return resolve(undefined);
                }, 0);
              });
            }, {
              oncePoll: provider
            }));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
}

function getRunner(config, currentBlockNumber, method, params) {
  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
    var provider, filter;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            provider = config.provider;
            _context2.t0 = method;
            _context2.next = _context2.t0 === "getBlockNumber" ? 4 : _context2.t0 === "getGasPrice" ? 4 : _context2.t0 === "getEtherPrice" ? 5 : _context2.t0 === "getBalance" ? 8 : _context2.t0 === "getTransactionCount" ? 8 : _context2.t0 === "getCode" ? 8 : _context2.t0 === "getStorageAt" ? 13 : _context2.t0 === "getBlock" ? 18 : _context2.t0 === "call" ? 23 : _context2.t0 === "estimateGas" ? 23 : _context2.t0 === "getTransaction" ? 28 : _context2.t0 === "getTransactionReceipt" ? 28 : _context2.t0 === "getLogs" ? 29 : 35;
            break;

          case 4:
            return _context2.abrupt("return", provider[method]());

          case 5:
            if (!provider.getEtherPrice) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", provider.getEtherPrice());

          case 7:
            return _context2.abrupt("break", 35);

          case 8:
            if (!(params.blockTag && isHexString(params.blockTag))) {
              _context2.next = 12;
              break;
            }

            _context2.next = 11;
            return waitForSync(config, currentBlockNumber);

          case 11:
            provider = _context2.sent;

          case 12:
            return _context2.abrupt("return", provider[method](params.address, params.blockTag || "latest"));

          case 13:
            if (!(params.blockTag && isHexString(params.blockTag))) {
              _context2.next = 17;
              break;
            }

            _context2.next = 16;
            return waitForSync(config, currentBlockNumber);

          case 16:
            provider = _context2.sent;

          case 17:
            return _context2.abrupt("return", provider.getStorageAt(params.address, params.position, params.blockTag || "latest"));

          case 18:
            if (!(params.blockTag && isHexString(params.blockTag))) {
              _context2.next = 22;
              break;
            }

            _context2.next = 21;
            return waitForSync(config, currentBlockNumber);

          case 21:
            provider = _context2.sent;

          case 22:
            return _context2.abrupt("return", provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash));

          case 23:
            if (!(params.blockTag && isHexString(params.blockTag))) {
              _context2.next = 27;
              break;
            }

            _context2.next = 26;
            return waitForSync(config, currentBlockNumber);

          case 26:
            provider = _context2.sent;

          case 27:
            return _context2.abrupt("return", provider[method](params.transaction));

          case 28:
            return _context2.abrupt("return", provider[method](params.transactionHash));

          case 29:
            filter = params.filter;

            if (!(filter.fromBlock && isHexString(filter.fromBlock) || filter.toBlock && isHexString(filter.toBlock))) {
              _context2.next = 34;
              break;
            }

            _context2.next = 33;
            return waitForSync(config, currentBlockNumber);

          case 33:
            provider = _context2.sent;

          case 34:
            return _context2.abrupt("return", provider.getLogs(filter));

          case 35:
            return _context2.abrupt("return", logger.throwError("unknown method error", Logger.errors.UNKNOWN_ERROR, {
              method: method,
              params: params
            }));

          case 36:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
}

export var FallbackProvider = /*#__PURE__*/function (_BaseProvider) {
  _inherits(FallbackProvider, _BaseProvider);

  var _super = _createSuper(FallbackProvider);

  function FallbackProvider(providers, quorum) {
    var _this;

    _classCallCheck(this, FallbackProvider);

    logger.checkNew(this instanceof FallbackProvider ? this.constructor : void 0, FallbackProvider);

    if (providers.length === 0) {
      logger.throwArgumentError("missing providers", "providers", providers);
    }

    var providerConfigs = providers.map(function (configOrProvider, index) {
      if (Provider.isProvider(configOrProvider)) {
        var stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;
        var priority = 1;
        return Object.freeze({
          provider: configOrProvider,
          weight: 1,
          stallTimeout: stallTimeout,
          priority: priority
        });
      }

      var config = shallowCopy(configOrProvider);

      if (config.priority == null) {
        config.priority = 1;
      }

      if (config.stallTimeout == null) {
        config.stallTimeout = isCommunityResource(configOrProvider) ? 2000 : 750;
      }

      if (config.weight == null) {
        config.weight = 1;
      }

      var weight = config.weight;

      if (weight % 1 || weight > 512 || weight < 1) {
        logger.throwArgumentError("invalid weight; must be integer in [1, 512]", "providers[".concat(index, "].weight"), weight);
      }

      return Object.freeze(config);
    });
    var total = providerConfigs.reduce(function (accum, c) {
      return accum + c.weight;
    }, 0);

    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    } // Are all providers' networks are known


    var networkOrReady = checkNetworks(providerConfigs.map(function (c) {
      return c.provider.network;
    })); // Not all networks are known; we must stall

    if (networkOrReady == null) {
      networkOrReady = new Promise(function (resolve, reject) {
        setTimeout(function () {
          _this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }

    _this = _super.call(this, networkOrReady); // Preserve a copy, so we do not get mutated

    defineReadOnly(_assertThisInitialized(_this), "providerConfigs", Object.freeze(providerConfigs));
    defineReadOnly(_assertThisInitialized(_this), "quorum", quorum);
    _this._highestBlockNumber = -1;
    return _this;
  }

  _createClass(FallbackProvider, [{
    key: "detectNetwork",
    value: function detectNetwork() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var networks;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return Promise.all(this.providerConfigs.map(function (c) {
                  return c.provider.getNetwork();
                }));

              case 2:
                networks = _context3.sent;
                return _context3.abrupt("return", checkNetworks(networks));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
    }
  }, {
    key: "perform",
    value: function perform(method, params) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this2 = this;

        var results, _i, result, processFunc, configs, currentBlockNumber, i, first, _loop, _ret;

        return _regeneratorRuntime.wrap(function _callee4$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                if (!(method === "sendTransaction")) {
                  _context5.next = 13;
                  break;
                }

                _context5.next = 3;
                return Promise.all(this.providerConfigs.map(function (c) {
                  return c.provider.sendTransaction(params.signedTransaction).then(function (result) {
                    return result.hash;
                  }, function (error) {
                    return error;
                  });
                }));

              case 3:
                results = _context5.sent;
                _i = 0;

              case 5:
                if (!(_i < results.length)) {
                  _context5.next = 12;
                  break;
                }

                result = results[_i];

                if (!(typeof result === "string")) {
                  _context5.next = 9;
                  break;
                }

                return _context5.abrupt("return", result);

              case 9:
                _i++;
                _context5.next = 5;
                break;

              case 12:
                throw results[0];

              case 13:
                if (!(this._highestBlockNumber === -1 && method !== "getBlockNumber")) {
                  _context5.next = 16;
                  break;
                }

                _context5.next = 16;
                return this.getBlockNumber();

              case 16:
                processFunc = getProcessFunc(this, method, params); // Shuffle the providers and then sort them by their priority; we
                // shallowCopy them since we will store the result in them too

                configs = shuffled(this.providerConfigs.map(shallowCopy));
                configs.sort(function (a, b) {
                  return a.priority - b.priority;
                });
                currentBlockNumber = this._highestBlockNumber;
                i = 0;
                first = true;
                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {
                  var t0, inflightWeight, _loop2, waiting, results, _result, errors;

                  return _regeneratorRuntime.wrap(function _loop$(_context4) {
                    while (1) {
                      switch (_context4.prev = _context4.next) {
                        case 0:
                          t0 = now(); // Compute the inflight weight (exclude anything past)

                          inflightWeight = configs.filter(function (c) {
                            return c.runner && t0 - c.start < c.stallTimeout;
                          }).reduce(function (accum, c) {
                            return accum + c.weight;
                          }, 0); // Start running enough to meet quorum

                          _loop2 = function _loop2() {
                            var config = configs[i++];
                            var rid = nextRid++;
                            config.start = now();
                            config.staller = stall(config.stallTimeout);
                            config.staller.wait(function () {
                              config.staller = null;
                            });
                            config.runner = getRunner(config, currentBlockNumber, method, params).then(function (result) {
                              config.done = true;
                              config.result = result;

                              if (_this2.listenerCount("debug")) {
                                _this2.emit("debug", {
                                  action: "request",
                                  rid: rid,
                                  backend: exposeDebugConfig(config, now()),
                                  request: {
                                    method: method,
                                    params: deepCopy(params)
                                  },
                                  provider: _this2
                                });
                              }
                            }, function (error) {
                              config.done = true;
                              config.error = error;

                              if (_this2.listenerCount("debug")) {
                                _this2.emit("debug", {
                                  action: "request",
                                  rid: rid,
                                  backend: exposeDebugConfig(config, now()),
                                  request: {
                                    method: method,
                                    params: deepCopy(params)
                                  },
                                  provider: _this2
                                });
                              }
                            });

                            if (_this2.listenerCount("debug")) {
                              _this2.emit("debug", {
                                action: "request",
                                rid: rid,
                                backend: exposeDebugConfig(config, null),
                                request: {
                                  method: method,
                                  params: deepCopy(params)
                                },
                                provider: _this2
                              });
                            }

                            inflightWeight += config.weight;
                          };

                          while (inflightWeight < _this2.quorum && i < configs.length) {
                            _loop2();
                          } // Wait for anything meaningful to finish or stall out


                          waiting = [];
                          configs.forEach(function (c) {
                            if (c.done || !c.runner) {
                              return;
                            }

                            waiting.push(c.runner);

                            if (c.staller) {
                              waiting.push(c.staller.getPromise());
                            }
                          });

                          if (!waiting.length) {
                            _context4.next = 9;
                            break;
                          }

                          _context4.next = 9;
                          return Promise.race(waiting);

                        case 9:
                          // Check the quorum and process the results; the process function
                          // may additionally decide the quorum is not met
                          results = configs.filter(function (c) {
                            return c.done && c.error == null;
                          });

                          if (!(results.length >= _this2.quorum)) {
                            _context4.next = 19;
                            break;
                          }

                          _result = processFunc(results);

                          if (!(_result !== undefined)) {
                            _context4.next = 15;
                            break;
                          }

                          // Shut down any stallers
                          configs.forEach(function (c) {
                            if (c.staller) {
                              c.staller.cancel();
                            }

                            c.cancelled = true;
                          });
                          return _context4.abrupt("return", {
                            v: _result
                          });

                        case 15:
                          if (first) {
                            _context4.next = 18;
                            break;
                          }

                          _context4.next = 18;
                          return stall(100).getPromise();

                        case 18:
                          first = false;

                        case 19:
                          // No result, check for errors that should be forwarded
                          errors = configs.reduce(function (accum, c) {
                            if (!c.done || c.error == null) {
                              return accum;
                            }

                            var code = c.error.code;

                            if (ForwardErrors.indexOf(code) >= 0) {
                              if (!accum[code]) {
                                accum[code] = {
                                  error: c.error,
                                  weight: 0
                                };
                              }

                              accum[code].weight += c.weight;
                            }

                            return accum;
                          }, {});
                          Object.keys(errors).forEach(function (errorCode) {
                            var tally = errors[errorCode];

                            if (tally.weight < _this2.quorum) {
                              return;
                            } // Shut down any stallers


                            configs.forEach(function (c) {
                              if (c.staller) {
                                c.staller.cancel();
                              }

                              c.cancelled = true;
                            });
                            var e = tally.error;
                            var props = {};
                            ForwardProperties.forEach(function (name) {
                              if (e[name] == null) {
                                return;
                              }

                              props[name] = e[name];
                            });
                            logger.throwError(e.reason || e.message, errorCode, props);
                          }); // All configs have run to completion; we will never get more data

                          if (!(configs.filter(function (c) {
                            return !c.done;
                          }).length === 0)) {
                            _context4.next = 23;
                            break;
                          }

                          return _context4.abrupt("return", "break");

                        case 23:
                        case "end":
                          return _context4.stop();
                      }
                    }
                  }, _loop);
                });

              case 23:
                if (!true) {
                  _context5.next = 32;
                  break;
                }

                return _context5.delegateYield(_loop(), "t0", 25);

              case 25:
                _ret = _context5.t0;

                if (!(_ret === "break")) {
                  _context5.next = 28;
                  break;
                }

                return _context5.abrupt("break", 32);

              case 28:
                if (!(typeof _ret === "object")) {
                  _context5.next = 30;
                  break;
                }

                return _context5.abrupt("return", _ret.v);

              case 30:
                _context5.next = 23;
                break;

              case 32:
                // Shut down any stallers; shouldn't be any
                configs.forEach(function (c) {
                  if (c.staller) {
                    c.staller.cancel();
                  }

                  c.cancelled = true;
                });
                return _context5.abrupt("return", logger.throwError("failed to meet quorum", Logger.errors.SERVER_ERROR, {
                  method: method,
                  params: params,
                  //results: configs.map((c) => c.result),
                  //errors: configs.map((c) => c.error),
                  results: configs.map(function (c) {
                    return exposeDebugConfig(c);
                  }),
                  provider: this
                }));

              case 34:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee4, this);
      }));
    }
  }]);

  return FallbackProvider;
}(BaseProvider);