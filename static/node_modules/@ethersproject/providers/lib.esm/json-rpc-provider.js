"use strict";

import _get from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/get";
import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";
import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _assertThisInitialized from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/assertThisInitialized";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { Signer } from "@ethersproject/abstract-signer";
import { BigNumber } from "@ethersproject/bignumber";
import { hexlify, hexValue, isHexString } from "@ethersproject/bytes";
import { _TypedDataEncoder } from "@ethersproject/hash";
import { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from "@ethersproject/properties";
import { toUtf8Bytes } from "@ethersproject/strings";
import { accessListify } from "@ethersproject/transactions";
import { fetchJson, poll } from "@ethersproject/web";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);
import { BaseProvider } from "./base-provider";
var errorGas = ["call", "estimateGas"];

function spelunk(value) {
  if (value == null) {
    return null;
  } // These *are* the droids we're looking for.


  if (typeof value.message === "string" && value.message.match("reverted") && isHexString(value.data)) {
    return {
      message: value.message,
      data: value.data
    };
  } // Spelunk further...


  if (typeof value === "object") {
    for (var key in value) {
      var result = spelunk(value[key]);

      if (result) {
        return result;
      }
    }

    return null;
  } // Might be a JSON string we can further descend...


  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value));
    } catch (error) {}
  }

  return null;
}

function checkError(method, error, params) {
  // Undo the "convenience" some nodes are attempting to prevent backwards
  // incompatibility; maybe for v6 consider forwarding reverts as errors
  if (method === "call") {
    var result = spelunk(error);

    if (result) {
      return result.data;
    }

    logger.throwError("missing revert data in call exception; Transaction reverted without a reason string", Logger.errors.CALL_EXCEPTION, {
      error: error,
      data: "0x"
    });
  } // @TODO: Should we spelunk for message too?


  var message = error.message;

  if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }

  message = (message || "").toLowerCase();
  var transaction = params.transaction || params.signedTransaction; // "insufficient funds for gas * price + value + cost(data)"

  if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
    logger.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error: error,
      method: method,
      transaction: transaction
    });
  } // "nonce too low"


  if (message.match(/nonce (is )?too low/)) {
    logger.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error: error,
      method: method,
      transaction: transaction
    });
  } // "replacement transaction underpriced"


  if (message.match(/replacement transaction underpriced/)) {
    logger.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error: error,
      method: method,
      transaction: transaction
    });
  } // "replacement transaction underpriced"


  if (message.match(/only replay-protected/)) {
    logger.throwError("legacy pre-eip-155 transactions not supported", Logger.errors.UNSUPPORTED_OPERATION, {
      error: error,
      method: method,
      transaction: transaction
    });
  }

  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error: error,
      method: method,
      transaction: transaction
    });
  }

  throw error;
}

function timer(timeout) {
  return new Promise(function (resolve) {
    setTimeout(resolve, timeout);
  });
}

function getResult(payload) {
  if (payload.error) {
    // @TODO: not any
    var error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }

  return payload.result;
}

function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }

  return value;
}

var _constructorGuard = {};
export var JsonRpcSigner = /*#__PURE__*/function (_Signer) {
  _inherits(JsonRpcSigner, _Signer);

  var _super = _createSuper(JsonRpcSigner);

  function JsonRpcSigner(constructorGuard, provider, addressOrIndex) {
    var _this;

    _classCallCheck(this, JsonRpcSigner);

    logger.checkNew(this instanceof JsonRpcSigner ? this.constructor : void 0, JsonRpcSigner);
    _this = _super.call(this);

    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }

    defineReadOnly(_assertThisInitialized(_this), "provider", provider);

    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }

    if (typeof addressOrIndex === "string") {
      defineReadOnly(_assertThisInitialized(_this), "_address", _this.provider.formatter.address(addressOrIndex));
      defineReadOnly(_assertThisInitialized(_this), "_index", null);
    } else if (typeof addressOrIndex === "number") {
      defineReadOnly(_assertThisInitialized(_this), "_index", addressOrIndex);
      defineReadOnly(_assertThisInitialized(_this), "_address", null);
    } else {
      logger.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }

    return _this;
  }

  _createClass(JsonRpcSigner, [{
    key: "connect",
    value: function connect(provider) {
      return logger.throwError("cannot alter JSON-RPC Signer connection", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "connect"
      });
    }
  }, {
    key: "connectUnchecked",
    value: function connectUnchecked() {
      return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
    }
  }, {
    key: "getAddress",
    value: function getAddress() {
      var _this2 = this;

      if (this._address) {
        return Promise.resolve(this._address);
      }

      return this.provider.send("eth_accounts", []).then(function (accounts) {
        if (accounts.length <= _this2._index) {
          logger.throwError("unknown account #" + _this2._index, Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "getAddress"
          });
        }

        return _this2.provider.formatter.address(accounts[_this2._index]);
      });
    }
  }, {
    key: "sendUncheckedTransaction",
    value: function sendUncheckedTransaction(transaction) {
      var _this3 = this;

      transaction = shallowCopy(transaction);
      var fromAddress = this.getAddress().then(function (address) {
        if (address) {
          address = address.toLowerCase();
        }

        return address;
      }); // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
      // wishes to use this, it is easy to specify explicitly, otherwise
      // we look it up for them.

      if (transaction.gasLimit == null) {
        var estimate = shallowCopy(transaction);
        estimate.from = fromAddress;
        transaction.gasLimit = this.provider.estimateGas(estimate);
      }

      if (transaction.to != null) {
        transaction.to = Promise.resolve(transaction.to).then(function (to) {
          return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
            var address;
            return _regeneratorRuntime.wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    if (!(to == null)) {
                      _context.next = 2;
                      break;
                    }

                    return _context.abrupt("return", null);

                  case 2:
                    _context.next = 4;
                    return this.provider.resolveName(to);

                  case 4:
                    address = _context.sent;

                    if (address == null) {
                      logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                    }

                    return _context.abrupt("return", address);

                  case 7:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee, this);
          }));
        });
      }

      return resolveProperties({
        tx: resolveProperties(transaction),
        sender: fromAddress
      }).then(function (_ref) {
        var tx = _ref.tx,
            sender = _ref.sender;

        if (tx.from != null) {
          if (tx.from.toLowerCase() !== sender) {
            logger.throwArgumentError("from address mismatch", "transaction", transaction);
          }
        } else {
          tx.from = sender;
        }

        var hexTx = _this3.provider.constructor.hexlifyTransaction(tx, {
          from: true
        });

        return _this3.provider.send("eth_sendTransaction", [hexTx]).then(function (hash) {
          return hash;
        }, function (error) {
          return checkError("sendTransaction", error, hexTx);
        });
      });
    }
  }, {
    key: "signTransaction",
    value: function signTransaction(transaction) {
      return logger.throwError("signing transactions is unsupported", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "signTransaction"
      });
    }
  }, {
    key: "sendTransaction",
    value: function sendTransaction(transaction) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this4 = this;

        var blockNumber, hash;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);

              case 2:
                blockNumber = _context3.sent;
                _context3.next = 5;
                return this.sendUncheckedTransaction(transaction);

              case 5:
                hash = _context3.sent;
                _context3.prev = 6;
                _context3.next = 9;
                return poll(function () {
                  return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
                    var tx;
                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return this.provider.getTransaction(hash);

                          case 2:
                            tx = _context2.sent;

                            if (!(tx === null)) {
                              _context2.next = 5;
                              break;
                            }

                            return _context2.abrupt("return", undefined);

                          case 5:
                            return _context2.abrupt("return", this.provider._wrapTransaction(tx, hash, blockNumber));

                          case 6:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2, this);
                  }));
                }, {
                  oncePoll: this.provider
                });

              case 9:
                return _context3.abrupt("return", _context3.sent);

              case 12:
                _context3.prev = 12;
                _context3.t0 = _context3["catch"](6);
                _context3.t0.transactionHash = hash;
                throw _context3.t0;

              case 16:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[6, 12]]);
      }));
    }
  }, {
    key: "signMessage",
    value: function signMessage(message) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var data, address;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                data = typeof message === "string" ? toUtf8Bytes(message) : message;
                _context4.next = 3;
                return this.getAddress();

              case 3:
                address = _context4.sent;
                _context4.next = 6;
                return this.provider.send("personal_sign", [hexlify(data), address.toLowerCase()]);

              case 6:
                return _context4.abrupt("return", _context4.sent);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
    }
  }, {
    key: "_legacySignMessage",
    value: function _legacySignMessage(message) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var data, address;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                data = typeof message === "string" ? toUtf8Bytes(message) : message;
                _context5.next = 3;
                return this.getAddress();

              case 3:
                address = _context5.sent;
                _context5.next = 6;
                return this.provider.send("eth_sign", [address.toLowerCase(), hexlify(data)]);

              case 6:
                return _context5.abrupt("return", _context5.sent);

              case 7:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
    }
  }, {
    key: "_signTypedData",
    value: function _signTypedData(domain, types, value) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var _this5 = this;

        var populated, address;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return _TypedDataEncoder.resolveNames(domain, types, value, function (name) {
                  return _this5.provider.resolveName(name);
                });

              case 2:
                populated = _context6.sent;
                _context6.next = 5;
                return this.getAddress();

              case 5:
                address = _context6.sent;
                _context6.next = 8;
                return this.provider.send("eth_signTypedData_v4", [address.toLowerCase(), JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);

              case 8:
                return _context6.abrupt("return", _context6.sent);

              case 9:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
    }
  }, {
    key: "unlock",
    value: function unlock(password) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
        var provider, address;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                provider = this.provider;
                _context7.next = 3;
                return this.getAddress();

              case 3:
                address = _context7.sent;
                return _context7.abrupt("return", provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]));

              case 5:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
    }
  }]);

  return JsonRpcSigner;
}(Signer);

var UncheckedJsonRpcSigner = /*#__PURE__*/function (_JsonRpcSigner) {
  _inherits(UncheckedJsonRpcSigner, _JsonRpcSigner);

  var _super2 = _createSuper(UncheckedJsonRpcSigner);

  function UncheckedJsonRpcSigner() {
    _classCallCheck(this, UncheckedJsonRpcSigner);

    return _super2.apply(this, arguments);
  }

  _createClass(UncheckedJsonRpcSigner, [{
    key: "sendTransaction",
    value: function sendTransaction(transaction) {
      var _this6 = this;

      return this.sendUncheckedTransaction(transaction).then(function (hash) {
        return {
          hash: hash,
          nonce: null,
          gasLimit: null,
          gasPrice: null,
          data: null,
          value: null,
          chainId: null,
          confirmations: 0,
          from: null,
          wait: function wait(confirmations) {
            return _this6.provider.waitForTransaction(hash, confirmations);
          }
        };
      });
    }
  }]);

  return UncheckedJsonRpcSigner;
}(JsonRpcSigner);

var allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
export var JsonRpcProvider = /*#__PURE__*/function (_BaseProvider) {
  _inherits(JsonRpcProvider, _BaseProvider);

  var _super3 = _createSuper(JsonRpcProvider);

  function JsonRpcProvider(url, network) {
    var _this7;

    _classCallCheck(this, JsonRpcProvider);

    logger.checkNew(this instanceof JsonRpcProvider ? this.constructor : void 0, JsonRpcProvider);
    var networkOrReady = network; // The network is unknown, query the JSON-RPC for it

    if (networkOrReady == null) {
      networkOrReady = new Promise(function (resolve, reject) {
        setTimeout(function () {
          _this7.detectNetwork().then(function (network) {
            resolve(network);
          }, function (error) {
            reject(error);
          });
        }, 0);
      });
    }

    _this7 = _super3.call(this, networkOrReady); // Default URL

    if (!url) {
      url = getStatic(_this7.constructor, "defaultUrl")();
    }

    if (typeof url === "string") {
      defineReadOnly(_assertThisInitialized(_this7), "connection", Object.freeze({
        url: url
      }));
    } else {
      defineReadOnly(_assertThisInitialized(_this7), "connection", Object.freeze(shallowCopy(url)));
    }

    _this7._nextId = 42;
    return _this7;
  }

  _createClass(JsonRpcProvider, [{
    key: "_cache",
    get: function get() {
      if (this._eventLoopCache == null) {
        this._eventLoopCache = {};
      }

      return this._eventLoopCache;
    }
  }, {
    key: "detectNetwork",
    value: function detectNetwork() {
      var _this8 = this;

      if (!this._cache["detectNetwork"]) {
        this._cache["detectNetwork"] = this._uncachedDetectNetwork(); // Clear this cache at the beginning of the next event loop

        setTimeout(function () {
          _this8._cache["detectNetwork"] = null;
        }, 0);
      }

      return this._cache["detectNetwork"];
    }
  }, {
    key: "_uncachedDetectNetwork",
    value: function _uncachedDetectNetwork() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
        var chainId, getNetwork;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return timer(0);

              case 2:
                chainId = null;
                _context8.prev = 3;
                _context8.next = 6;
                return this.send("eth_chainId", []);

              case 6:
                chainId = _context8.sent;
                _context8.next = 19;
                break;

              case 9:
                _context8.prev = 9;
                _context8.t0 = _context8["catch"](3);
                _context8.prev = 11;
                _context8.next = 14;
                return this.send("net_version", []);

              case 14:
                chainId = _context8.sent;
                _context8.next = 19;
                break;

              case 17:
                _context8.prev = 17;
                _context8.t1 = _context8["catch"](11);

              case 19:
                if (!(chainId != null)) {
                  _context8.next = 28;
                  break;
                }

                getNetwork = getStatic(this.constructor, "getNetwork");
                _context8.prev = 21;
                return _context8.abrupt("return", getNetwork(BigNumber.from(chainId).toNumber()));

              case 25:
                _context8.prev = 25;
                _context8.t2 = _context8["catch"](21);
                return _context8.abrupt("return", logger.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
                  chainId: chainId,
                  event: "invalidNetwork",
                  serverError: _context8.t2
                }));

              case 28:
                return _context8.abrupt("return", logger.throwError("could not detect network", Logger.errors.NETWORK_ERROR, {
                  event: "noNetwork"
                }));

              case 29:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this, [[3, 9], [11, 17], [21, 25]]);
      }));
    }
  }, {
    key: "getSigner",
    value: function getSigner(addressOrIndex) {
      return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
    }
  }, {
    key: "getUncheckedSigner",
    value: function getUncheckedSigner(addressOrIndex) {
      return this.getSigner(addressOrIndex).connectUnchecked();
    }
  }, {
    key: "listAccounts",
    value: function listAccounts() {
      var _this9 = this;

      return this.send("eth_accounts", []).then(function (accounts) {
        return accounts.map(function (a) {
          return _this9.formatter.address(a);
        });
      });
    }
  }, {
    key: "send",
    value: function send(method, params) {
      var _this10 = this;

      var request = {
        method: method,
        params: params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };
      this.emit("debug", {
        action: "request",
        request: deepCopy(request),
        provider: this
      }); // We can expand this in the future to any call, but for now these
      // are the biggest wins and do not require any serializing parameters.

      var cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;

      if (cache && this._cache[method]) {
        return this._cache[method];
      }

      var result = fetchJson(this.connection, JSON.stringify(request), getResult).then(function (result) {
        _this10.emit("debug", {
          action: "response",
          request: request,
          response: result,
          provider: _this10
        });

        return result;
      }, function (error) {
        _this10.emit("debug", {
          action: "response",
          error: error,
          request: request,
          provider: _this10
        });

        throw error;
      }); // Cache the fetch, but clear it on the next event loop

      if (cache) {
        this._cache[method] = result;
        setTimeout(function () {
          _this10._cache[method] = null;
        }, 0);
      }

      return result;
    }
  }, {
    key: "prepareRequest",
    value: function prepareRequest(method, params) {
      switch (method) {
        case "getBlockNumber":
          return ["eth_blockNumber", []];

        case "getGasPrice":
          return ["eth_gasPrice", []];

        case "getBalance":
          return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];

        case "getTransactionCount":
          return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];

        case "getCode":
          return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];

        case "getStorageAt":
          return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];

        case "sendTransaction":
          return ["eth_sendRawTransaction", [params.signedTransaction]];

        case "getBlock":
          if (params.blockTag) {
            return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
          } else if (params.blockHash) {
            return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
          }

          return null;

        case "getTransaction":
          return ["eth_getTransactionByHash", [params.transactionHash]];

        case "getTransactionReceipt":
          return ["eth_getTransactionReceipt", [params.transactionHash]];

        case "call":
          {
            var hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");
            return ["eth_call", [hexlifyTransaction(params.transaction, {
              from: true
            }), params.blockTag]];
          }

        case "estimateGas":
          {
            var _hexlifyTransaction = getStatic(this.constructor, "hexlifyTransaction");

            return ["eth_estimateGas", [_hexlifyTransaction(params.transaction, {
              from: true
            })]];
          }

        case "getLogs":
          if (params.filter && params.filter.address != null) {
            params.filter.address = getLowerCase(params.filter.address);
          }

          return ["eth_getLogs", [params.filter]];

        default:
          break;
      }

      return null;
    }
  }, {
    key: "perform",
    value: function perform(method, params) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        var tx, feeData, args;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!(method === "call" || method === "estimateGas")) {
                  _context9.next = 8;
                  break;
                }

                tx = params.transaction;

                if (!(tx && tx.type != null && BigNumber.from(tx.type).isZero())) {
                  _context9.next = 8;
                  break;
                }

                if (!(tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null)) {
                  _context9.next = 8;
                  break;
                }

                _context9.next = 6;
                return this.getFeeData();

              case 6:
                feeData = _context9.sent;

                if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                  // Network doesn't know about EIP-1559 (and hence type)
                  params = shallowCopy(params);
                  params.transaction = shallowCopy(tx);
                  delete params.transaction.type;
                }

              case 8:
                args = this.prepareRequest(method, params);

                if (args == null) {
                  logger.throwError(method + " not implemented", Logger.errors.NOT_IMPLEMENTED, {
                    operation: method
                  });
                }

                _context9.prev = 10;
                _context9.next = 13;
                return this.send(args[0], args[1]);

              case 13:
                return _context9.abrupt("return", _context9.sent);

              case 16:
                _context9.prev = 16;
                _context9.t0 = _context9["catch"](10);
                return _context9.abrupt("return", checkError(method, _context9.t0, params));

              case 19:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this, [[10, 16]]);
      }));
    }
  }, {
    key: "_startEvent",
    value: function _startEvent(event) {
      if (event.tag === "pending") {
        this._startPending();
      }

      _get(_getPrototypeOf(JsonRpcProvider.prototype), "_startEvent", this).call(this, event);
    }
  }, {
    key: "_startPending",
    value: function _startPending() {
      if (this._pendingFilter != null) {
        return;
      }

      var self = this;
      var pendingFilter = this.send("eth_newPendingTransactionFilter", []);
      this._pendingFilter = pendingFilter;
      pendingFilter.then(function (filterId) {
        function poll() {
          self.send("eth_getFilterChanges", [filterId]).then(function (hashes) {
            if (self._pendingFilter != pendingFilter) {
              return null;
            }

            var seq = Promise.resolve();
            hashes.forEach(function (hash) {
              // @TODO: This should be garbage collected at some point... How? When?
              self._emitted["t:" + hash.toLowerCase()] = "pending";
              seq = seq.then(function () {
                return self.getTransaction(hash).then(function (tx) {
                  self.emit("pending", tx);
                  return null;
                });
              });
            });
            return seq.then(function () {
              return timer(1000);
            });
          }).then(function () {
            if (self._pendingFilter != pendingFilter) {
              self.send("eth_uninstallFilter", [filterId]);
              return;
            }

            setTimeout(function () {
              poll();
            }, 0);
            return null;
          }).catch(function (error) {});
        }

        poll();
        return filterId;
      }).catch(function (error) {});
    }
  }, {
    key: "_stopEvent",
    value: function _stopEvent(event) {
      if (event.tag === "pending" && this.listenerCount("pending") === 0) {
        this._pendingFilter = null;
      }

      _get(_getPrototypeOf(JsonRpcProvider.prototype), "_stopEvent", this).call(this, event);
    } // Convert an ethers.js transaction into a JSON-RPC transaction
    //  - gasLimit => gas
    //  - All values hexlified
    //  - All numeric values zero-striped
    //  - All addresses are lowercased
    // NOTE: This allows a TransactionRequest, but all values should be resolved
    //       before this is called
    // @TODO: This will likely be removed in future versions and prepareRequest
    //        will be the preferred method for this.

  }], [{
    key: "defaultUrl",
    value: function defaultUrl() {
      return "http:/\/localhost:8545";
    }
  }, {
    key: "hexlifyTransaction",
    value: function hexlifyTransaction(transaction, allowExtra) {
      // Check only allowed properties are given
      var allowed = shallowCopy(allowedTransactionKeys);

      if (allowExtra) {
        for (var key in allowExtra) {
          if (allowExtra[key]) {
            allowed[key] = true;
          }
        }
      }

      checkProperties(transaction, allowed);
      var result = {}; // JSON-RPC now requires numeric values to be "quantity" values

      ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
        if (transaction[key] == null) {
          return;
        }

        var value = hexValue(transaction[key]);

        if (key === "gasLimit") {
          key = "gas";
        }

        result[key] = value;
      });
      ["from", "to", "data"].forEach(function (key) {
        if (transaction[key] == null) {
          return;
        }

        result[key] = hexlify(transaction[key]);
      });

      if (transaction.accessList) {
        result["accessList"] = accessListify(transaction.accessList);
      }

      return result;
    }
  }]);

  return JsonRpcProvider;
}(BaseProvider);