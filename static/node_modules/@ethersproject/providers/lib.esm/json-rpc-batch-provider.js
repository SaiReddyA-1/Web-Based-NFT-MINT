import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { deepCopy } from "@ethersproject/properties";
import { fetchJson } from "@ethersproject/web";
import { JsonRpcProvider } from "./json-rpc-provider"; // Experimental

export var JsonRpcBatchProvider = /*#__PURE__*/function (_JsonRpcProvider) {
  _inherits(JsonRpcBatchProvider, _JsonRpcProvider);

  var _super = _createSuper(JsonRpcBatchProvider);

  function JsonRpcBatchProvider() {
    _classCallCheck(this, JsonRpcBatchProvider);

    return _super.apply(this, arguments);
  }

  _createClass(JsonRpcBatchProvider, [{
    key: "send",
    value: function send(method, params) {
      var _this = this;

      var request = {
        method: method,
        params: params,
        id: this._nextId++,
        jsonrpc: "2.0"
      };

      if (this._pendingBatch == null) {
        this._pendingBatch = [];
      }

      var inflightRequest = {
        request: request,
        resolve: null,
        reject: null
      };
      var promise = new Promise(function (resolve, reject) {
        inflightRequest.resolve = resolve;
        inflightRequest.reject = reject;
      });

      this._pendingBatch.push(inflightRequest);

      if (!this._pendingBatchAggregator) {
        // Schedule batch for next event loop + short duration
        this._pendingBatchAggregator = setTimeout(function () {
          // Get teh current batch and clear it, so new requests
          // go into the next batch
          var batch = _this._pendingBatch;
          _this._pendingBatch = null;
          _this._pendingBatchAggregator = null; // Get the request as an array of requests

          var request = batch.map(function (inflight) {
            return inflight.request;
          });

          _this.emit("debug", {
            action: "requestBatch",
            request: deepCopy(request),
            provider: _this
          });

          return fetchJson(_this.connection, JSON.stringify(request)).then(function (result) {
            _this.emit("debug", {
              action: "response",
              request: request,
              response: result,
              provider: _this
            }); // For each result, feed it to the correct Promise, depending
            // on whether it was a success or error


            batch.forEach(function (inflightRequest, index) {
              var payload = result[index];

              if (payload.error) {
                var error = new Error(payload.error.message);
                error.code = payload.error.code;
                error.data = payload.error.data;
                inflightRequest.reject(error);
              } else {
                inflightRequest.resolve(payload.result);
              }
            });
          }, function (error) {
            _this.emit("debug", {
              action: "response",
              error: error,
              request: request,
              provider: _this
            });

            batch.forEach(function (inflightRequest) {
              inflightRequest.reject(error);
            });
          });
        }, 10);
      }

      return promise;
    }
  }]);

  return JsonRpcBatchProvider;
}(JsonRpcProvider);