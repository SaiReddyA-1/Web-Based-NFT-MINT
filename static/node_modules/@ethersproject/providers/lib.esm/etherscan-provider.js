"use strict";

import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";
import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _assertThisInitialized from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/assertThisInitialized";
import _get from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/get";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { hexlify, hexValue, isHexString } from "@ethersproject/bytes";
import { deepCopy, defineReadOnly } from "@ethersproject/properties";
import { accessListify } from "@ethersproject/transactions";
import { fetchJson } from "@ethersproject/web";
import { showThrottleMessage } from "./formatter";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);
import { BaseProvider } from "./base-provider"; // The transaction has already been sanitized by the calls in Provider

function getTransactionPostData(transaction) {
  var result = {};

  for (var key in transaction) {
    if (transaction[key] == null) {
      continue;
    }

    var value = transaction[key];

    if (key === "type" && value === 0) {
      continue;
    } // Quantity-types require no leading zero, unless 0


    if ({
      type: true,
      gasLimit: true,
      gasPrice: true,
      maxFeePerGs: true,
      maxPriorityFeePerGas: true,
      nonce: true,
      value: true
    }[key]) {
      value = hexValue(hexlify(value));
    } else if (key === "accessList") {
      value = "[" + accessListify(value).map(function (set) {
        return "{address:\"".concat(set.address, "\",storageKeys:[\"").concat(set.storageKeys.join('","'), "\"]}");
      }).join(",") + "]";
    } else {
      value = hexlify(value);
    }

    result[key] = value;
  }

  return result;
}

function getResult(result) {
  // getLogs, getHistory have weird success responses
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }

  if (result.status != 1 || result.message != "OK") {
    var error = new Error("invalid response");
    error.result = JSON.stringify(result);

    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }

    throw error;
  }

  return result.result;
}

function getJsonResult(result) {
  // This response indicates we are being throttled
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    var error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }

  if (result.jsonrpc != "2.0") {
    // @TODO: not any
    var _error = new Error("invalid response");

    _error.result = JSON.stringify(result);
    throw _error;
  }

  if (result.error) {
    // @TODO: not any
    var _error2 = new Error(result.error.message || "unknown error");

    if (result.error.code) {
      _error2.code = result.error.code;
    }

    if (result.error.data) {
      _error2.data = result.error.data;
    }

    throw _error2;
  }

  return result.result;
} // The blockTag was normalized as a string by the Provider pre-perform operations


function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }

  if (blockTag === "latest") {
    return blockTag;
  }

  return parseInt(blockTag.substring(2), 16);
}

var defaultApiKey = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";

function checkError(method, error, transaction) {
  // Undo the "convenience" some nodes are attempting to prevent backwards
  // incompatibility; maybe for v6 consider forwarding reverts as errors
  if (method === "call" && error.code === Logger.errors.SERVER_ERROR) {
    var e = error.error; // Etherscan keeps changing their string

    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      // Etherscan prefixes the data like "Reverted 0x1234"
      var data = e.data;

      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }

      if (isHexString(data)) {
        return data;
      }

      logger.throwError("missing revert data in call exception", Logger.errors.CALL_EXCEPTION, {
        error: error,
        data: "0x"
      });
    }
  } // Get the message from any nested error structure


  var message = error.message;

  if (error.code === Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }

  message = (message || "").toLowerCase(); // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"

  if (message.match(/insufficient funds/)) {
    logger.throwError("insufficient funds for intrinsic transaction cost", Logger.errors.INSUFFICIENT_FUNDS, {
      error: error,
      method: method,
      transaction: transaction
    });
  } // "Transaction with the same hash was already imported."


  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger.throwError("nonce has already been used", Logger.errors.NONCE_EXPIRED, {
      error: error,
      method: method,
      transaction: transaction
    });
  } // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."


  if (message.match(/another transaction with same nonce/)) {
    logger.throwError("replacement fee too low", Logger.errors.REPLACEMENT_UNDERPRICED, {
      error: error,
      method: method,
      transaction: transaction
    });
  }

  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error: error,
      method: method,
      transaction: transaction
    });
  }

  throw error;
}

export var EtherscanProvider = /*#__PURE__*/function (_BaseProvider) {
  _inherits(EtherscanProvider, _BaseProvider);

  var _super2 = _createSuper(EtherscanProvider);

  function EtherscanProvider(network, apiKey) {
    var _this;

    _classCallCheck(this, EtherscanProvider);

    logger.checkNew(this instanceof EtherscanProvider ? this.constructor : void 0, EtherscanProvider);
    _this = _super2.call(this, network);
    defineReadOnly(_assertThisInitialized(_this), "baseUrl", _this.getBaseUrl());
    defineReadOnly(_assertThisInitialized(_this), "apiKey", apiKey || defaultApiKey);
    return _this;
  }

  _createClass(EtherscanProvider, [{
    key: "getBaseUrl",
    value: function getBaseUrl() {
      switch (this.network ? this.network.name : "invalid") {
        case "homestead":
          return "https:/\/api.etherscan.io";

        case "ropsten":
          return "https:/\/api-ropsten.etherscan.io";

        case "rinkeby":
          return "https:/\/api-rinkeby.etherscan.io";

        case "kovan":
          return "https:/\/api-kovan.etherscan.io";

        case "goerli":
          return "https:/\/api-goerli.etherscan.io";

        default:
      }

      return logger.throwArgumentError("unsupported network", "network", name);
    }
  }, {
    key: "getUrl",
    value: function getUrl(module, params) {
      var query = Object.keys(params).reduce(function (accum, key) {
        var value = params[key];

        if (value != null) {
          accum += "&".concat(key, "=").concat(value);
        }

        return accum;
      }, "");
      var apiKey = this.apiKey ? "&apikey=".concat(this.apiKey) : "";
      return "".concat(this.baseUrl, "/api?module=").concat(module).concat(query).concat(apiKey);
    }
  }, {
    key: "getPostUrl",
    value: function getPostUrl() {
      return "".concat(this.baseUrl, "/api");
    }
  }, {
    key: "getPostData",
    value: function getPostData(module, params) {
      params.module = module;
      params.apikey = this.apiKey;
      return params;
    }
  }, {
    key: "fetch",
    value: function fetch(module, params, post) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this2 = this;

        var url, payload, procFunc, connection, payloadStr, result;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                url = post ? this.getPostUrl() : this.getUrl(module, params);
                payload = post ? this.getPostData(module, params) : null;
                procFunc = module === "proxy" ? getJsonResult : getResult;
                this.emit("debug", {
                  action: "request",
                  request: url,
                  provider: this
                });
                connection = {
                  url: url,
                  throttleSlotInterval: 1000,
                  throttleCallback: function throttleCallback(attempt, url) {
                    if (_this2.isCommunityResource()) {
                      showThrottleMessage();
                    }

                    return Promise.resolve(true);
                  }
                };
                payloadStr = null;

                if (payload) {
                  connection.headers = {
                    "content-type": "application/x-www-form-urlencoded; charset=UTF-8"
                  };
                  payloadStr = Object.keys(payload).map(function (key) {
                    return "".concat(key, "=").concat(payload[key]);
                  }).join("&");
                }

                _context.next = 9;
                return fetchJson(connection, payloadStr, procFunc || getJsonResult);

              case 9:
                result = _context.sent;
                this.emit("debug", {
                  action: "response",
                  request: url,
                  response: deepCopy(result),
                  provider: this
                });
                return _context.abrupt("return", result);

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "detectNetwork",
    value: function detectNetwork() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                return _context2.abrupt("return", this.network);

              case 1:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
    }
  }, {
    key: "perform",
    value: function perform(method, params) {
      var _this3 = this;

      var _super = Object.create(null, {
        perform: {
          get: function get() {
            return _get(_getPrototypeOf(EtherscanProvider.prototype), "perform", _this3);
          }
        }
      });

      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var postData, _postData, args, topic0, logs, blocks, i, log, block;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.t0 = method;
                _context3.next = _context3.t0 === "getBlockNumber" ? 3 : _context3.t0 === "getGasPrice" ? 4 : _context3.t0 === "getBalance" ? 5 : _context3.t0 === "getTransactionCount" ? 6 : _context3.t0 === "getCode" ? 7 : _context3.t0 === "getStorageAt" ? 8 : _context3.t0 === "sendTransaction" ? 9 : _context3.t0 === "getBlock" ? 10 : _context3.t0 === "getTransaction" ? 13 : _context3.t0 === "getTransactionReceipt" ? 14 : _context3.t0 === "call" ? 15 : _context3.t0 === "estimateGas" ? 29 : _context3.t0 === "getLogs" ? 41 : _context3.t0 === "getEtherPrice" ? 65 : 72;
                break;

              case 3:
                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_blockNumber"
                }));

              case 4:
                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_gasPrice"
                }));

              case 5:
                return _context3.abrupt("return", this.fetch("account", {
                  action: "balance",
                  address: params.address,
                  tag: params.blockTag
                }));

              case 6:
                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_getTransactionCount",
                  address: params.address,
                  tag: params.blockTag
                }));

              case 7:
                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_getCode",
                  address: params.address,
                  tag: params.blockTag
                }));

              case 8:
                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_getStorageAt",
                  address: params.address,
                  position: params.position,
                  tag: params.blockTag
                }));

              case 9:
                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_sendRawTransaction",
                  hex: params.signedTransaction
                }, true).catch(function (error) {
                  return checkError("sendTransaction", error, params.signedTransaction);
                }));

              case 10:
                if (!params.blockTag) {
                  _context3.next = 12;
                  break;
                }

                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_getBlockByNumber",
                  tag: params.blockTag,
                  boolean: params.includeTransactions ? "true" : "false"
                }));

              case 12:
                throw new Error("getBlock by blockHash not implemented");

              case 13:
                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_getTransactionByHash",
                  txhash: params.transactionHash
                }));

              case 14:
                return _context3.abrupt("return", this.fetch("proxy", {
                  action: "eth_getTransactionReceipt",
                  txhash: params.transactionHash
                }));

              case 15:
                if (!(params.blockTag !== "latest")) {
                  _context3.next = 17;
                  break;
                }

                throw new Error("EtherscanProvider does not support blockTag for call");

              case 17:
                postData = getTransactionPostData(params.transaction);
                postData.module = "proxy";
                postData.action = "eth_call";
                _context3.prev = 20;
                _context3.next = 23;
                return this.fetch("proxy", postData, true);

              case 23:
                return _context3.abrupt("return", _context3.sent);

              case 26:
                _context3.prev = 26;
                _context3.t1 = _context3["catch"](20);
                return _context3.abrupt("return", checkError("call", _context3.t1, params.transaction));

              case 29:
                _postData = getTransactionPostData(params.transaction);
                _postData.module = "proxy";
                _postData.action = "eth_estimateGas";
                _context3.prev = 32;
                _context3.next = 35;
                return this.fetch("proxy", _postData, true);

              case 35:
                return _context3.abrupt("return", _context3.sent);

              case 38:
                _context3.prev = 38;
                _context3.t2 = _context3["catch"](32);
                return _context3.abrupt("return", checkError("estimateGas", _context3.t2, params.transaction));

              case 41:
                args = {
                  action: "getLogs"
                };

                if (params.filter.fromBlock) {
                  args.fromBlock = checkLogTag(params.filter.fromBlock);
                }

                if (params.filter.toBlock) {
                  args.toBlock = checkLogTag(params.filter.toBlock);
                }

                if (params.filter.address) {
                  args.address = params.filter.address;
                } // @TODO: We can handle slightly more complicated logs using the logs API


                if (params.filter.topics && params.filter.topics.length > 0) {
                  if (params.filter.topics.length > 1) {
                    logger.throwError("unsupported topic count", Logger.errors.UNSUPPORTED_OPERATION, {
                      topics: params.filter.topics
                    });
                  }

                  if (params.filter.topics.length === 1) {
                    topic0 = params.filter.topics[0];

                    if (typeof topic0 !== "string" || topic0.length !== 66) {
                      logger.throwError("unsupported topic format", Logger.errors.UNSUPPORTED_OPERATION, {
                        topic0: topic0
                      });
                    }

                    args.topic0 = topic0;
                  }
                }

                _context3.next = 48;
                return this.fetch("logs", args);

              case 48:
                logs = _context3.sent;
                // Cache txHash => blockHash
                blocks = {}; // Add any missing blockHash to the logs

                i = 0;

              case 51:
                if (!(i < logs.length)) {
                  _context3.next = 64;
                  break;
                }

                log = logs[i];

                if (!(log.blockHash != null)) {
                  _context3.next = 55;
                  break;
                }

                return _context3.abrupt("continue", 61);

              case 55:
                if (!(blocks[log.blockNumber] == null)) {
                  _context3.next = 60;
                  break;
                }

                _context3.next = 58;
                return this.getBlock(log.blockNumber);

              case 58:
                block = _context3.sent;

                if (block) {
                  blocks[log.blockNumber] = block.hash;
                }

              case 60:
                log.blockHash = blocks[log.blockNumber];

              case 61:
                i++;
                _context3.next = 51;
                break;

              case 64:
                return _context3.abrupt("return", logs);

              case 65:
                if (!(this.network.name !== "homestead")) {
                  _context3.next = 67;
                  break;
                }

                return _context3.abrupt("return", 0.0);

              case 67:
                _context3.t3 = parseFloat;
                _context3.next = 70;
                return this.fetch("stats", {
                  action: "ethprice"
                });

              case 70:
                _context3.t4 = _context3.sent.ethusd;
                return _context3.abrupt("return", (0, _context3.t3)(_context3.t4));

              case 72:
                return _context3.abrupt("break", 73);

              case 73:
                return _context3.abrupt("return", _super.perform.call(this, method, params));

              case 74:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this, [[20, 26], [32, 38]]);
      }));
    } // Note: The `page` page parameter only allows pagination within the
    //       10,000 window available without a page and offset parameter
    //       Error: Result window is too large, PageNo x Offset size must
    //              be less than or equal to 10000

  }, {
    key: "getHistory",
    value: function getHistory(addressOrName, startBlock, endBlock) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this4 = this;

        var params, result;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.resolveName(addressOrName);

              case 2:
                _context4.t0 = _context4.sent;
                _context4.t1 = startBlock == null ? 0 : startBlock;
                _context4.t2 = endBlock == null ? 99999999 : endBlock;
                params = {
                  action: "txlist",
                  address: _context4.t0,
                  startblock: _context4.t1,
                  endblock: _context4.t2,
                  sort: "asc"
                };
                _context4.next = 8;
                return this.fetch("account", params);

              case 8:
                result = _context4.sent;
                return _context4.abrupt("return", result.map(function (tx) {
                  ["contractAddress", "to"].forEach(function (key) {
                    if (tx[key] == "") {
                      delete tx[key];
                    }
                  });

                  if (tx.creates == null && tx.contractAddress != null) {
                    tx.creates = tx.contractAddress;
                  }

                  var item = _this4.formatter.transactionResponse(tx);

                  if (tx.timeStamp) {
                    item.timestamp = parseInt(tx.timeStamp);
                  }

                  return item;
                }));

              case 10:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
    }
  }, {
    key: "isCommunityResource",
    value: function isCommunityResource() {
      return this.apiKey === defaultApiKey;
    }
  }]);

  return EtherscanProvider;
}(BaseProvider);