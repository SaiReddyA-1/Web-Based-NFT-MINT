import { concat, hexlify } from "@ethersproject/bytes";
import { nameprep, toUtf8Bytes } from "@ethersproject/strings";
import { keccak256 } from "@ethersproject/keccak256";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);
var Zeros = new Uint8Array(32);
Zeros.fill(0);
var Partition = new RegExp("^((.*)\\.)?([^.]+)$");
export function isValidName(name) {
  try {
    var comps = name.split(".");

    for (var i = 0; i < comps.length; i++) {
      if (nameprep(comps[i]).length === 0) {
        throw new Error("empty");
      }
    }

    return true;
  } catch (error) {}

  return false;
}
export function namehash(name) {
  /* istanbul ignore if */
  if (typeof name !== "string") {
    logger.throwArgumentError("invalid ENS name; not a string", "name", name);
  }

  var current = name;
  var result = Zeros;

  while (current.length) {
    var partition = current.match(Partition);

    if (partition == null || partition[2] === "") {
      logger.throwArgumentError("invalid ENS address; missing component", "name", name);
    }

    var label = toUtf8Bytes(nameprep(partition[3]));
    result = keccak256(concat([result, keccak256(label)]));
    current = partition[2] || "";
  }

  return hexlify(result);
}
export function dnsEncode(name) {
  return hexlify(concat(name.split(".").map(function (comp) {
    // We jam in an _ prefix to fill in with the length later
    // Note: Nameprep throws if the component is over 63 bytes
    var bytes = toUtf8Bytes("_" + nameprep(comp));
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}