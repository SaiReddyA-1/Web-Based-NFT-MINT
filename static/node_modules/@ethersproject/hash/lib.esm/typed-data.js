import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";
import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { getAddress } from "@ethersproject/address";
import { BigNumber } from "@ethersproject/bignumber";
import { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from "@ethersproject/bytes";
import { keccak256 } from "@ethersproject/keccak256";
import { deepCopy, defineReadOnly, shallowCopy } from "@ethersproject/properties";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);
import { id } from "./id";
var padding = new Uint8Array(32);
padding.fill(0);
var NegativeOne = BigNumber.from(-1);
var Zero = BigNumber.from(0);
var One = BigNumber.from(1);
var MaxUint256 = BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function hexPadRight(value) {
  var bytes = arrayify(value);
  var padOffset = bytes.length % 32;

  if (padOffset) {
    return hexConcat([bytes, padding.slice(padOffset)]);
  }

  return hexlify(bytes);
}

var hexTrue = hexZeroPad(One.toHexString(), 32);
var hexFalse = hexZeroPad(Zero.toHexString(), 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];

function checkString(key) {
  return function (value) {
    if (typeof value !== "string") {
      logger.throwArgumentError("invalid domain value for ".concat(JSON.stringify(key)), "domain.".concat(key), value);
    }

    return value;
  };
}

var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function chainId(value) {
    try {
      return BigNumber.from(value).toString();
    } catch (error) {}

    return logger.throwArgumentError("invalid domain value for \"chainId\"", "domain.chainId", value);
  },
  verifyingContract: function verifyingContract(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {}

    return logger.throwArgumentError("invalid domain value \"verifyingContract\"", "domain.verifyingContract", value);
  },
  salt: function salt(value) {
    try {
      var bytes = arrayify(value);

      if (bytes.length !== 32) {
        throw new Error("bad length");
      }

      return hexlify(bytes);
    } catch (error) {}

    return logger.throwArgumentError("invalid domain value \"salt\"", "domain.salt", value);
  }
};

function getBaseEncoder(type) {
  // intXX and uintXX
  {
    var match = type.match(/^(u?)int(\d*)$/);

    if (match) {
      var signed = match[1] === "";
      var width = parseInt(match[2] || "256");

      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger.throwArgumentError("invalid numeric width", "type", type);
      }

      var boundsUpper = MaxUint256.mask(signed ? width - 1 : width);
      var boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function (value) {
        var v = BigNumber.from(value);

        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger.throwArgumentError("value out-of-bounds for ".concat(type), "value", value);
        }

        return hexZeroPad(v.toTwos(256).toHexString(), 32);
      };
    }
  } // bytesXX

  {
    var _match = type.match(/^bytes(\d+)$/);

    if (_match) {
      var _width = parseInt(_match[1]);

      if (_width === 0 || _width > 32 || _match[1] !== String(_width)) {
        logger.throwArgumentError("invalid bytes width", "type", type);
      }

      return function (value) {
        var bytes = arrayify(value);

        if (bytes.length !== _width) {
          logger.throwArgumentError("invalid length for ".concat(type), "value", value);
        }

        return hexPadRight(value);
      };
    }
  }

  switch (type) {
    case "address":
      return function (value) {
        return hexZeroPad(getAddress(value), 32);
      };

    case "bool":
      return function (value) {
        return !value ? hexFalse : hexTrue;
      };

    case "bytes":
      return function (value) {
        return keccak256(value);
      };

    case "string":
      return function (value) {
        return id(value);
      };
  }

  return null;
}

function encodeType(name, fields) {
  return "".concat(name, "(").concat(fields.map(function (_ref) {
    var name = _ref.name,
        type = _ref.type;
    return type + " " + name;
  }).join(","), ")");
}

export var TypedDataEncoder = /*#__PURE__*/function () {
  function TypedDataEncoder(types) {
    _classCallCheck(this, TypedDataEncoder);

    defineReadOnly(this, "types", Object.freeze(deepCopy(types)));
    defineReadOnly(this, "_encoderCache", {});
    defineReadOnly(this, "_types", {}); // Link struct types to their direct child structs

    var links = {}; // Link structs to structs which contain them as a child

    var parents = {}; // Link all subtypes within a given struct

    var subtypes = {};
    Object.keys(types).forEach(function (type) {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });

    var _loop = function _loop(name) {
      var uniqueNames = {};
      types[name].forEach(function (field) {
        // Check each field has a unique name
        if (uniqueNames[field.name]) {
          logger.throwArgumentError("duplicate variable name ".concat(JSON.stringify(field.name), " in ").concat(JSON.stringify(name)), "types", types);
        }

        uniqueNames[field.name] = true; // Get the base type (drop any array specifiers)

        var baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];

        if (baseType === name) {
          logger.throwArgumentError("circular type reference to ".concat(JSON.stringify(baseType)), "types", types);
        } // Is this a base encoding type?


        var encoder = getBaseEncoder(baseType);

        if (encoder) {
          return;
        }

        if (!parents[baseType]) {
          logger.throwArgumentError("unknown type ".concat(JSON.stringify(baseType)), "types", types);
        } // Add linkage


        parents[baseType].push(name);
        links[name][baseType] = true;
      });
    };

    for (var name in types) {
      _loop(name);
    } // Deduce the primary type


    var primaryTypes = Object.keys(parents).filter(function (n) {
      return parents[n].length === 0;
    });

    if (primaryTypes.length === 0) {
      logger.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger.throwArgumentError("ambiguous primary types or unused types: ".concat(primaryTypes.map(function (t) {
        return JSON.stringify(t);
      }).join(", ")), "types", types);
    }

    defineReadOnly(this, "primaryType", primaryTypes[0]); // Check for circular type references

    function checkCircular(type, found) {
      if (found[type]) {
        logger.throwArgumentError("circular type reference to ".concat(JSON.stringify(type)), "types", types);
      }

      found[type] = true;
      Object.keys(links[type]).forEach(function (child) {
        if (!parents[child]) {
          return;
        } // Recursively check children


        checkCircular(child, found); // Mark all ancestors as having this decendant

        Object.keys(found).forEach(function (subtype) {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }

    checkCircular(this.primaryType, {}); // Compute each fully describe type

    for (var _name in subtypes) {
      var st = Object.keys(subtypes[_name]);
      st.sort();
      this._types[_name] = encodeType(_name, types[_name]) + st.map(function (t) {
        return encodeType(t, types[t]);
      }).join("");
    }
  }

  _createClass(TypedDataEncoder, [{
    key: "getEncoder",
    value: function getEncoder(type) {
      var encoder = this._encoderCache[type];

      if (!encoder) {
        encoder = this._encoderCache[type] = this._getEncoder(type);
      }

      return encoder;
    }
  }, {
    key: "_getEncoder",
    value: function _getEncoder(type) {
      var _this = this;

      // Basic encoder type (address, bool, uint256, etc)
      {
        var encoder = getBaseEncoder(type);

        if (encoder) {
          return encoder;
        }
      } // Array

      var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);

      if (match) {
        var subtype = match[1];
        var subEncoder = this.getEncoder(subtype);
        var length = parseInt(match[3]);
        return function (value) {
          if (length >= 0 && value.length !== length) {
            logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
          }

          var result = value.map(subEncoder);

          if (_this._types[subtype]) {
            result = result.map(keccak256);
          }

          return keccak256(hexConcat(result));
        };
      } // Struct


      var fields = this.types[type];

      if (fields) {
        var encodedType = id(this._types[type]);
        return function (value) {
          var values = fields.map(function (_ref2) {
            var name = _ref2.name,
                type = _ref2.type;

            var result = _this.getEncoder(type)(value[name]);

            if (_this._types[type]) {
              return keccak256(result);
            }

            return result;
          });
          values.unshift(encodedType);
          return hexConcat(values);
        };
      }

      return logger.throwArgumentError("unknown type: ".concat(type), "type", type);
    }
  }, {
    key: "encodeType",
    value: function encodeType(name) {
      var result = this._types[name];

      if (!result) {
        logger.throwArgumentError("unknown type: ".concat(JSON.stringify(name)), "name", name);
      }

      return result;
    }
  }, {
    key: "encodeData",
    value: function encodeData(type, value) {
      return this.getEncoder(type)(value);
    }
  }, {
    key: "hashStruct",
    value: function hashStruct(name, value) {
      return keccak256(this.encodeData(name, value));
    }
  }, {
    key: "encode",
    value: function encode(value) {
      return this.encodeData(this.primaryType, value);
    }
  }, {
    key: "hash",
    value: function hash(value) {
      return this.hashStruct(this.primaryType, value);
    }
  }, {
    key: "_visit",
    value: function _visit(type, value, callback) {
      var _this2 = this;

      // Basic encoder type (address, bool, uint256, etc)
      {
        var encoder = getBaseEncoder(type);

        if (encoder) {
          return callback(type, value);
        }
      } // Array

      var match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);

      if (match) {
        var subtype = match[1];
        var length = parseInt(match[3]);

        if (length >= 0 && value.length !== length) {
          logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }

        return value.map(function (v) {
          return _this2._visit(subtype, v, callback);
        });
      } // Struct


      var fields = this.types[type];

      if (fields) {
        return fields.reduce(function (accum, _ref3) {
          var name = _ref3.name,
              type = _ref3.type;
          accum[name] = _this2._visit(type, value[name], callback);
          return accum;
        }, {});
      }

      return logger.throwArgumentError("unknown type: ".concat(type), "type", type);
    }
  }, {
    key: "visit",
    value: function visit(value, callback) {
      return this._visit(this.primaryType, value, callback);
    }
  }], [{
    key: "from",
    value: function from(types) {
      return new TypedDataEncoder(types);
    }
  }, {
    key: "getPrimaryType",
    value: function getPrimaryType(types) {
      return TypedDataEncoder.from(types).primaryType;
    }
  }, {
    key: "hashStruct",
    value: function hashStruct(name, types, value) {
      return TypedDataEncoder.from(types).hashStruct(name, value);
    }
  }, {
    key: "hashDomain",
    value: function hashDomain(domain) {
      var domainFields = [];

      for (var name in domain) {
        var type = domainFieldTypes[name];

        if (!type) {
          logger.throwArgumentError("invalid typed-data domain key: ".concat(JSON.stringify(name)), "domain", domain);
        }

        domainFields.push({
          name: name,
          type: type
        });
      }

      domainFields.sort(function (a, b) {
        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
      });
      return TypedDataEncoder.hashStruct("EIP712Domain", {
        EIP712Domain: domainFields
      }, domain);
    }
  }, {
    key: "encode",
    value: function encode(domain, types, value) {
      return hexConcat(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
    }
  }, {
    key: "hash",
    value: function hash(domain, types, value) {
      return keccak256(TypedDataEncoder.encode(domain, types, value));
    } // Replaces all address types with ENS names with their looked up address

  }, {
    key: "resolveNames",
    value: function resolveNames(domain, types, value, resolveName) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var ensCache, encoder, name;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                // Make a copy to isolate it from the object passed in
                domain = shallowCopy(domain); // Look up all ENS names

                ensCache = {}; // Do we need to look up the domain's verifyingContract?

                if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {
                  ensCache[domain.verifyingContract] = "0x";
                } // We are going to use the encoder to visit all the base values


                encoder = TypedDataEncoder.from(types); // Get a list of all the addresses

                encoder.visit(value, function (type, value) {
                  if (type === "address" && !isHexString(value, 20)) {
                    ensCache[value] = "0x";
                  }

                  return value;
                }); // Lookup each name

                _context.t0 = _regeneratorRuntime.keys(ensCache);

              case 6:
                if ((_context.t1 = _context.t0()).done) {
                  _context.next = 13;
                  break;
                }

                name = _context.t1.value;
                _context.next = 10;
                return resolveName(name);

              case 10:
                ensCache[name] = _context.sent;
                _context.next = 6;
                break;

              case 13:
                // Replace the domain verifyingContract if needed
                if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                  domain.verifyingContract = ensCache[domain.verifyingContract];
                } // Replace all ENS names with their address


                value = encoder.visit(value, function (type, value) {
                  if (type === "address" && ensCache[value]) {
                    return ensCache[value];
                  }

                  return value;
                });
                return _context.abrupt("return", {
                  domain: domain,
                  value: value
                });

              case 16:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
    }
  }, {
    key: "getPayload",
    value: function getPayload(domain, types, value) {
      // Validate the domain fields
      TypedDataEncoder.hashDomain(domain); // Derive the EIP712Domain Struct reference type

      var domainValues = {};
      var domainTypes = [];
      domainFieldNames.forEach(function (name) {
        var value = domain[name];

        if (value == null) {
          return;
        }

        domainValues[name] = domainChecks[name](value);
        domainTypes.push({
          name: name,
          type: domainFieldTypes[name]
        });
      });
      var encoder = TypedDataEncoder.from(types);
      var typesWithDomain = shallowCopy(types);

      if (typesWithDomain.EIP712Domain) {
        logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
      } else {
        typesWithDomain.EIP712Domain = domainTypes;
      } // Validate the data structures and types


      encoder.encode(value);
      return {
        types: typesWithDomain,
        domain: domainValues,
        primaryType: encoder.primaryType,
        message: encoder.visit(value, function (type, value) {
          // bytes
          if (type.match(/^bytes(\d*)/)) {
            return hexlify(arrayify(value));
          } // uint or int


          if (type.match(/^u?int/)) {
            return BigNumber.from(value).toString();
          }

          switch (type) {
            case "address":
              return value.toLowerCase();

            case "bool":
              return !!value;

            case "string":
              if (typeof value !== "string") {
                logger.throwArgumentError("invalid string", "value", value);
              }

              return value;
          }

          return logger.throwArgumentError("unsupported type", "type", type);
        })
      };
    }
  }]);

  return TypedDataEncoder;
}();