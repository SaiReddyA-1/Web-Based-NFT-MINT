"use strict";

import _assertThisInitialized from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/assertThisInitialized";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";
import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";
import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { defineReadOnly, resolveProperties, shallowCopy } from "@ethersproject/properties";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);
var allowedTransactionKeys = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"];
var forwardErrors = [Logger.errors.INSUFFICIENT_FUNDS, Logger.errors.NONCE_EXPIRED, Logger.errors.REPLACEMENT_UNDERPRICED];
;
;
export var Signer = /*#__PURE__*/function () {
  ///////////////////
  // Sub-classes MUST call super
  function Signer() {
    _classCallCheck(this, Signer);

    logger.checkAbstract(this instanceof Signer ? this.constructor : void 0, Signer);
    defineReadOnly(this, "_isSigner", true);
  } ///////////////////
  // Sub-classes MAY override these


  _createClass(Signer, [{
    key: "getBalance",
    value: function getBalance(blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this._checkProvider("getBalance");

                _context.next = 3;
                return this.provider.getBalance(this.getAddress(), blockTag);

              case 3:
                return _context.abrupt("return", _context.sent);

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));
    }
  }, {
    key: "getTransactionCount",
    value: function getTransactionCount(blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this._checkProvider("getTransactionCount");

                _context2.next = 3;
                return this.provider.getTransactionCount(this.getAddress(), blockTag);

              case 3:
                return _context2.abrupt("return", _context2.sent);

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));
    } // Populates "from" if unspecified, and estimates the gas for the transaction

  }, {
    key: "estimateGas",
    value: function estimateGas(transaction) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var tx;
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this._checkProvider("estimateGas");

                _context3.next = 3;
                return resolveProperties(this.checkTransaction(transaction));

              case 3:
                tx = _context3.sent;
                _context3.next = 6;
                return this.provider.estimateGas(tx);

              case 6:
                return _context3.abrupt("return", _context3.sent);

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));
    } // Populates "from" if unspecified, and calls with the transaction

  }, {
    key: "call",
    value: function call(transaction, blockTag) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var tx;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                this._checkProvider("call");

                _context4.next = 3;
                return resolveProperties(this.checkTransaction(transaction));

              case 3:
                tx = _context4.sent;
                _context4.next = 6;
                return this.provider.call(tx, blockTag);

              case 6:
                return _context4.abrupt("return", _context4.sent);

              case 7:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));
    } // Populates all fields in a transaction, signs it and sends it to the network

  }, {
    key: "sendTransaction",
    value: function sendTransaction(transaction) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var tx, signedTx;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                this._checkProvider("sendTransaction");

                _context5.next = 3;
                return this.populateTransaction(transaction);

              case 3:
                tx = _context5.sent;
                _context5.next = 6;
                return this.signTransaction(tx);

              case 6:
                signedTx = _context5.sent;
                _context5.next = 9;
                return this.provider.sendTransaction(signedTx);

              case 9:
                return _context5.abrupt("return", _context5.sent);

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));
    }
  }, {
    key: "getChainId",
    value: function getChainId() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var network;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                this._checkProvider("getChainId");

                _context6.next = 3;
                return this.provider.getNetwork();

              case 3:
                network = _context6.sent;
                return _context6.abrupt("return", network.chainId);

              case 5:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));
    }
  }, {
    key: "getGasPrice",
    value: function getGasPrice() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                this._checkProvider("getGasPrice");

                _context7.next = 3;
                return this.provider.getGasPrice();

              case 3:
                return _context7.abrupt("return", _context7.sent);

              case 4:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));
    }
  }, {
    key: "getFeeData",
    value: function getFeeData() {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                this._checkProvider("getFeeData");

                _context8.next = 3;
                return this.provider.getFeeData();

              case 3:
                return _context8.abrupt("return", _context8.sent);

              case 4:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));
    }
  }, {
    key: "resolveName",
    value: function resolveName(name) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                this._checkProvider("resolveName");

                _context9.next = 3;
                return this.provider.resolveName(name);

              case 3:
                return _context9.abrupt("return", _context9.sent);

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));
    } // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)

  }, {
    key: "checkTransaction",
    value: function checkTransaction(transaction) {
      for (var key in transaction) {
        if (allowedTransactionKeys.indexOf(key) === -1) {
          logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
        }
      }

      var tx = shallowCopy(transaction);

      if (tx.from == null) {
        tx.from = this.getAddress();
      } else {
        // Make sure any provided address matches this signer
        tx.from = Promise.all([Promise.resolve(tx.from), this.getAddress()]).then(function (result) {
          if (result[0].toLowerCase() !== result[1].toLowerCase()) {
            logger.throwArgumentError("from address mismatch", "transaction", transaction);
          }

          return result[0];
        });
      }

      return tx;
    } // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas

  }, {
    key: "populateTransaction",
    value: function populateTransaction(transaction) {
      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
        var _this = this;

        var tx, hasEip1559, feeData, gasPrice;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                _context11.next = 2;
                return resolveProperties(this.checkTransaction(transaction));

              case 2:
                tx = _context11.sent;

                if (tx.to != null) {
                  tx.to = Promise.resolve(tx.to).then(function (to) {
                    return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
                      var address;
                      return _regeneratorRuntime.wrap(function _callee10$(_context10) {
                        while (1) {
                          switch (_context10.prev = _context10.next) {
                            case 0:
                              if (!(to == null)) {
                                _context10.next = 2;
                                break;
                              }

                              return _context10.abrupt("return", null);

                            case 2:
                              _context10.next = 4;
                              return this.resolveName(to);

                            case 4:
                              address = _context10.sent;

                              if (address == null) {
                                logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                              }

                              return _context10.abrupt("return", address);

                            case 7:
                            case "end":
                              return _context10.stop();
                          }
                        }
                      }, _callee10, this);
                    }));
                  }); // Prevent this error from causing an UnhandledPromiseException

                  tx.to.catch(function (error) {});
                } // Do not allow mixing pre-eip-1559 and eip-1559 properties


                hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;

                if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                  logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
                } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                  logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
                }

                if (!((tx.type === 2 || tx.type == null) && tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
                  _context11.next = 10;
                  break;
                }

                // Fully-formed EIP-1559 transaction (skip getFeeData)
                tx.type = 2;
                _context11.next = 18;
                break;

              case 10:
                if (!(tx.type === 0 || tx.type === 1)) {
                  _context11.next = 14;
                  break;
                }

                // Explicit Legacy or EIP-2930 transaction
                // Populate missing gasPrice
                if (tx.gasPrice == null) {
                  tx.gasPrice = this.getGasPrice();
                }

                _context11.next = 18;
                break;

              case 14:
                _context11.next = 16;
                return this.getFeeData();

              case 16:
                feeData = _context11.sent;

                if (tx.type == null) {
                  // We need to auto-detect the intended type of this transaction...
                  if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                    // The network supports EIP-1559!
                    // Upgrade transaction from null to eip-1559
                    tx.type = 2;

                    if (tx.gasPrice != null) {
                      // Using legacy gasPrice property on an eip-1559 network,
                      // so use gasPrice as both fee properties
                      gasPrice = tx.gasPrice;
                      delete tx.gasPrice;
                      tx.maxFeePerGas = gasPrice;
                      tx.maxPriorityFeePerGas = gasPrice;
                    } else {
                      // Populate missing fee data
                      if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                      }

                      if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                      }
                    }
                  } else if (feeData.gasPrice != null) {
                    // Network doesn't support EIP-1559...
                    // ...but they are trying to use EIP-1559 properties
                    if (hasEip1559) {
                      logger.throwError("network does not support EIP-1559", Logger.errors.UNSUPPORTED_OPERATION, {
                        operation: "populateTransaction"
                      });
                    } // Populate missing fee data


                    if (tx.gasPrice == null) {
                      tx.gasPrice = feeData.gasPrice;
                    } // Explicitly set untyped transaction to legacy


                    tx.type = 0;
                  } else {
                    // getFeeData has failed us.
                    logger.throwError("failed to get consistent fee data", Logger.errors.UNSUPPORTED_OPERATION, {
                      operation: "signer.getFeeData"
                    });
                  }
                } else if (tx.type === 2) {
                  // Explicitly using EIP-1559
                  // Populate missing fee data
                  if (tx.maxFeePerGas == null) {
                    tx.maxFeePerGas = feeData.maxFeePerGas;
                  }

                  if (tx.maxPriorityFeePerGas == null) {
                    tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                  }
                }

              case 18:
                if (tx.nonce == null) {
                  tx.nonce = this.getTransactionCount("pending");
                }

                if (tx.gasLimit == null) {
                  tx.gasLimit = this.estimateGas(tx).catch(function (error) {
                    if (forwardErrors.indexOf(error.code) >= 0) {
                      throw error;
                    }

                    return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                      error: error,
                      tx: tx
                    });
                  });
                }

                if (tx.chainId == null) {
                  tx.chainId = this.getChainId();
                } else {
                  tx.chainId = Promise.all([Promise.resolve(tx.chainId), this.getChainId()]).then(function (results) {
                    if (results[1] !== 0 && results[0] !== results[1]) {
                      logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
                    }

                    return results[0];
                  });
                }

                _context11.next = 23;
                return resolveProperties(tx);

              case 23:
                return _context11.abrupt("return", _context11.sent);

              case 24:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));
    } ///////////////////
    // Sub-classes SHOULD leave these alone

  }, {
    key: "_checkProvider",
    value: function _checkProvider(operation) {
      if (!this.provider) {
        logger.throwError("missing provider", Logger.errors.UNSUPPORTED_OPERATION, {
          operation: operation || "_checkProvider"
        });
      }
    }
  }], [{
    key: "isSigner",
    value: function isSigner(value) {
      return !!(value && value._isSigner);
    }
  }]);

  return Signer;
}();
export var VoidSigner = /*#__PURE__*/function (_Signer) {
  _inherits(VoidSigner, _Signer);

  var _super = _createSuper(VoidSigner);

  function VoidSigner(address, provider) {
    var _this2;

    _classCallCheck(this, VoidSigner);

    logger.checkNew(this instanceof VoidSigner ? this.constructor : void 0, VoidSigner);
    _this2 = _super.call(this);
    defineReadOnly(_assertThisInitialized(_this2), "address", address);
    defineReadOnly(_assertThisInitialized(_this2), "provider", provider || null);
    return _this2;
  }

  _createClass(VoidSigner, [{
    key: "getAddress",
    value: function getAddress() {
      return Promise.resolve(this.address);
    }
  }, {
    key: "_fail",
    value: function _fail(message, operation) {
      return Promise.resolve().then(function () {
        logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, {
          operation: operation
        });
      });
    }
  }, {
    key: "signMessage",
    value: function signMessage(message) {
      return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
  }, {
    key: "signTransaction",
    value: function signTransaction(transaction) {
      return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
  }, {
    key: "_signTypedData",
    value: function _signTypedData(domain, types, value) {
      return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
  }, {
    key: "connect",
    value: function connect(provider) {
      return new VoidSigner(this.address, provider);
    }
  }]);

  return VoidSigner;
}(Signer);