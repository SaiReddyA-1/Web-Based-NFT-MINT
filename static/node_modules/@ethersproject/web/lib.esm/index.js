"use strict";

import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

import { decode as base64Decode, encode as base64Encode } from "@ethersproject/base64";
import { hexlify, isBytesLike } from "@ethersproject/bytes";
import { shallowCopy } from "@ethersproject/properties";
import { toUtf8Bytes, toUtf8String } from "@ethersproject/strings";
import { Logger } from "@ethersproject/logger";
import { version } from "./_version";
var logger = new Logger(version);
import { getUrl } from "./geturl";

function staller(duration) {
  return new Promise(function (resolve) {
    setTimeout(resolve, duration);
  });
}

function bodyify(value, type) {
  if (value == null) {
    return null;
  }

  if (typeof value === "string") {
    return value;
  }

  if (isBytesLike(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return toUtf8String(value);
      } catch (error) {}

      ;
    }

    return hexlify(value);
  }

  return value;
} // This API is still a work in progress; the future changes will likely be:
// - ConnectionInfo => FetchDataRequest<T = any>
// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }
//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)
// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T
// For this reason, it should be considered internal until the API is finalized


export function _fetchData(connection, body, processFunc) {
  // How many times to retry in the event of a throttle
  var attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  var throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  var throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  var errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  var headers = {};
  var url = null; // @TODO: Allow ConnectionInfo to override some of these values

  var options = {
    method: "GET"
  };
  var allow304 = false;
  var timeout = 2 * 60 * 1000;

  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger.throwArgumentError("missing URL", "connection.url", connection);
    }

    url = connection.url;

    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }

    if (connection.headers) {
      for (var key in connection.headers) {
        headers[key.toLowerCase()] = {
          key: key,
          value: String(connection.headers[key])
        };

        if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }

    options.allowGzip = !!connection.allowGzip;

    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger.throwError("basic authentication requires a secure https url", Logger.errors.INVALID_ARGUMENT, {
          argument: "url",
          url: url,
          user: connection.user,
          password: "[REDACTED]"
        });
      }

      var authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + base64Encode(toUtf8Bytes(authorization))
      };
    }

    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
  }

  var reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  var dataMatch = url ? url.match(reData) : null;

  if (dataMatch) {
    try {
      var response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "content-type": dataMatch[1]
        },
        body: base64Decode(dataMatch[2])
      };
      var result = response.body;

      if (processFunc) {
        result = processFunc(response.body, response);
      }

      return Promise.resolve(result);
    } catch (error) {
      logger.throwError("processing response error", Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error: error,
        requestBody: null,
        requestMethod: "GET",
        url: url
      });
    }
  }

  if (body) {
    options.method = "POST";
    options.body = body;

    if (headers["content-type"] == null) {
      headers["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream"
      };
    }

    if (headers["content-length"] == null) {
      headers["content-length"] = {
        key: "Content-Length",
        value: String(body.length)
      };
    }
  }

  var flatHeaders = {};
  Object.keys(headers).forEach(function (key) {
    var header = headers[key];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;

  var runningTimeout = function () {
    var timer = null;
    var promise = new Promise(function (resolve, reject) {
      if (timeout) {
        timer = setTimeout(function () {
          if (timer == null) {
            return;
          }

          timer = null;
          reject(logger.makeError("timeout", Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout,
            url: url
          }));
        }, timeout);
      }
    });

    var cancel = function cancel() {
      if (timer == null) {
        return;
      }

      clearTimeout(timer);
      timer = null;
    };

    return {
      promise: promise,
      cancel: cancel
    };
  }();

  var runningFetch = function () {
    return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
      var attempt, _response, location, tryAgain, stall, retryAfter, _body, _result, _tryAgain, _timeout;

      return _regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              attempt = 0;

            case 1:
              if (!(attempt < attemptLimit)) {
                _context.next = 65;
                break;
              }

              _response = null;
              _context.prev = 3;
              _context.next = 6;
              return getUrl(url, options);

            case 6:
              _response = _context.sent;

              if (!(attempt < attemptLimit)) {
                _context.next = 28;
                break;
              }

              if (!(_response.statusCode === 301 || _response.statusCode === 302)) {
                _context.next = 15;
                break;
              }

              // Redirection; for now we only support absolute locataions
              location = _response.headers.location || "";

              if (!(options.method === "GET" && location.match(/^https:/))) {
                _context.next = 13;
                break;
              }

              url = _response.headers.location;
              return _context.abrupt("continue", 62);

            case 13:
              _context.next = 28;
              break;

            case 15:
              if (!(_response.statusCode === 429)) {
                _context.next = 28;
                break;
              }

              // Exponential back-off throttling
              tryAgain = true;

              if (!throttleCallback) {
                _context.next = 21;
                break;
              }

              _context.next = 20;
              return throttleCallback(attempt, url);

            case 20:
              tryAgain = _context.sent;

            case 21:
              if (!tryAgain) {
                _context.next = 28;
                break;
              }

              stall = 0;
              retryAfter = _response.headers["retry-after"];

              if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                stall = parseInt(retryAfter) * 1000;
              } else {
                stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
              } //console.log("Stalling 429");


              _context.next = 27;
              return staller(stall);

            case 27:
              return _context.abrupt("continue", 62);

            case 28:
              _context.next = 34;
              break;

            case 30:
              _context.prev = 30;
              _context.t0 = _context["catch"](3);
              _response = _context.t0.response;

              if (_response == null) {
                runningTimeout.cancel();
                logger.throwError("missing response", Logger.errors.SERVER_ERROR, {
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  serverError: _context.t0,
                  url: url
                });
              }

            case 34:
              _body = _response.body;

              if (allow304 && _response.statusCode === 304) {
                _body = null;
              } else if (!errorPassThrough && (_response.statusCode < 200 || _response.statusCode >= 300)) {
                runningTimeout.cancel();
                logger.throwError("bad response", Logger.errors.SERVER_ERROR, {
                  status: _response.statusCode,
                  headers: _response.headers,
                  body: bodyify(_body, _response.headers ? _response.headers["content-type"] : null),
                  requestBody: bodyify(options.body, flatHeaders["content-type"]),
                  requestMethod: options.method,
                  url: url
                });
              }

              if (!processFunc) {
                _context.next = 60;
                break;
              }

              _context.prev = 37;
              _context.next = 40;
              return processFunc(_body, _response);

            case 40:
              _result = _context.sent;
              runningTimeout.cancel();
              return _context.abrupt("return", _result);

            case 45:
              _context.prev = 45;
              _context.t1 = _context["catch"](37);

              if (!(_context.t1.throttleRetry && attempt < attemptLimit)) {
                _context.next = 58;
                break;
              }

              _tryAgain = true;

              if (!throttleCallback) {
                _context.next = 53;
                break;
              }

              _context.next = 52;
              return throttleCallback(attempt, url);

            case 52:
              _tryAgain = _context.sent;

            case 53:
              if (!_tryAgain) {
                _context.next = 58;
                break;
              }

              _timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt))); //console.log("Stalling callback");

              _context.next = 57;
              return staller(_timeout);

            case 57:
              return _context.abrupt("continue", 62);

            case 58:
              runningTimeout.cancel();
              logger.throwError("processing response error", Logger.errors.SERVER_ERROR, {
                body: bodyify(_body, _response.headers ? _response.headers["content-type"] : null),
                error: _context.t1,
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url: url
              });

            case 60:
              runningTimeout.cancel(); // If we had a processFunc, it either returned a T or threw above.
              // The "body" is now a Uint8Array.

              return _context.abrupt("return", _body);

            case 62:
              attempt++;
              _context.next = 1;
              break;

            case 65:
              return _context.abrupt("return", logger.throwError("failed response", Logger.errors.SERVER_ERROR, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url: url
              }));

            case 66:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, null, [[3, 30], [37, 45]]);
    }));
  }();

  return Promise.race([runningTimeout.promise, runningFetch]);
}
export function fetchJson(connection, json, processFunc) {
  var processJsonFunc = function processJsonFunc(value, response) {
    var result = null;

    if (value != null) {
      try {
        result = JSON.parse(toUtf8String(value));
      } catch (error) {
        logger.throwError("invalid JSON", Logger.errors.SERVER_ERROR, {
          body: value,
          error: error
        });
      }
    }

    if (processFunc) {
      result = processFunc(result, response);
    }

    return result;
  }; // If we have json to send, we must
  // - add content-type of application/json (unless already overridden)
  // - convert the json to bytes


  var body = null;

  if (json != null) {
    body = toUtf8Bytes(json); // Create a connection with the content-type set for JSON

    var updated = typeof connection === "string" ? {
      url: connection
    } : shallowCopy(connection);

    if (updated.headers) {
      var hasContentType = Object.keys(updated.headers).filter(function (k) {
        return k.toLowerCase() === "content-type";
      }).length !== 0;

      if (!hasContentType) {
        updated.headers = shallowCopy(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = {
        "content-type": "application/json"
      };
    }

    connection = updated;
  }

  return _fetchData(connection, body, processJsonFunc);
}
export function poll(func, options) {
  if (!options) {
    options = {};
  }

  options = shallowCopy(options);

  if (options.floor == null) {
    options.floor = 0;
  }

  if (options.ceiling == null) {
    options.ceiling = 10000;
  }

  if (options.interval == null) {
    options.interval = 250;
  }

  return new Promise(function (resolve, reject) {
    var timer = null;
    var done = false; // Returns true if cancel was successful. Unsuccessful cancel means we're already done.

    var cancel = function cancel() {
      if (done) {
        return false;
      }

      done = true;

      if (timer) {
        clearTimeout(timer);
      }

      return true;
    };

    if (options.timeout) {
      timer = setTimeout(function () {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }

    var retryLimit = options.retryLimit;
    var attempt = 0;

    function check() {
      return func().then(function (result) {
        // If we have a result, or are allowed null then we're done
        if (result !== undefined) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check); // Otherwise, exponential back-off (up to 10s) our next request
        } else if (!done) {
          attempt++;

          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }

            return;
          }

          var timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));

          if (timeout < options.floor) {
            timeout = options.floor;
          }

          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }

          setTimeout(check, timeout);
        }

        return null;
      }, function (error) {
        if (cancel()) {
          reject(error);
        }
      });
    }

    check();
  });
}