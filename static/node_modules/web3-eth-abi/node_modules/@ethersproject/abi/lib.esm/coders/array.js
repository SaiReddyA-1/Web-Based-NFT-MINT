"use strict";

import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import { Logger } from "@ethersproject/logger";
import { version } from "../_version";
var logger = new Logger(version);
import { Coder, Writer } from "./abstract-coder";
import { AnonymousCoder } from "./anonymous";
export function pack(writer, coders, values) {
  var arrayValues = null;

  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    var unique = {};
    arrayValues = coders.map(function (coder) {
      var name = coder.localName;

      if (!name) {
        logger.throwError("cannot encode object for signature with missing names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: coder,
          value: values
        });
      }

      if (unique[name]) {
        logger.throwError("cannot encode object for signature with duplicate names", Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: coder,
          value: values
        });
      }

      unique[name] = true;
      return values[name];
    });
  } else {
    logger.throwArgumentError("invalid tuple value", "tuple", values);
  }

  if (coders.length !== arrayValues.length) {
    logger.throwArgumentError("types/value length mismatch", "tuple", values);
  }

  var staticWriter = new Writer(writer.wordSize);
  var dynamicWriter = new Writer(writer.wordSize);
  var updateFuncs = [];
  coders.forEach(function (coder, index) {
    var value = arrayValues[index];

    if (coder.dynamic) {
      // Get current dynamic offset (for the future pointer)
      var dynamicOffset = dynamicWriter.length; // Encode the dynamic value into the dynamicWriter

      coder.encode(dynamicWriter, value); // Prepare to populate the correct offset once we are done

      var updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push(function (baseOffset) {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  }); // Backfill all the dynamic offsets, now that we know the static length

  updateFuncs.forEach(function (func) {
    func(staticWriter.length);
  });
  var length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
export function unpack(reader, coders) {
  var values = []; // A reader anchored to this base

  var baseReader = reader.subReader(0);
  coders.forEach(function (coder) {
    var value = null;

    if (coder.dynamic) {
      var offset = reader.readValue();
      var offsetReader = baseReader.subReader(offset.toNumber());

      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        // Cannot recover from this
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }

        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        // Cannot recover from this
        if (error.code === Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }

        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }

    if (value != undefined) {
      values.push(value);
    }
  }); // We only output named properties for uniquely named coders

  var uniqueNames = coders.reduce(function (accum, coder) {
    var name = coder.localName;

    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }

      accum[name]++;
    }

    return accum;
  }, {}); // Add any named parameters (i.e. tuples)

  coders.forEach(function (coder, index) {
    var name = coder.localName;

    if (!name || uniqueNames[name] !== 1) {
      return;
    }

    if (name === "length") {
      name = "_length";
    }

    if (values[name] != null) {
      return;
    }

    var value = values[index];

    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        get: function get() {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });

  var _loop = function _loop(i) {
    var value = values[i];

    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        get: function get() {
          throw value;
        }
      });
    }
  };

  for (var i = 0; i < values.length; i++) {
    _loop(i);
  }

  return Object.freeze(values);
}
export var ArrayCoder = /*#__PURE__*/function (_Coder) {
  _inherits(ArrayCoder, _Coder);

  var _super = _createSuper(ArrayCoder);

  function ArrayCoder(coder, length, localName) {
    var _this;

    _classCallCheck(this, ArrayCoder);

    var type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    var dynamic = length === -1 || coder.dynamic;
    _this = _super.call(this, "array", type, localName, dynamic);
    _this.coder = coder;
    _this.length = length;
    return _this;
  }

  _createClass(ArrayCoder, [{
    key: "encode",
    value: function encode(writer, value) {
      if (!Array.isArray(value)) {
        this._throwError("expected array value", value);
      }

      var count = this.length;

      if (count === -1) {
        count = value.length;
        writer.writeValue(value.length);
      }

      logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
      var coders = [];

      for (var i = 0; i < value.length; i++) {
        coders.push(this.coder);
      }

      return pack(writer, coders, value);
    }
  }, {
    key: "decode",
    value: function decode(reader) {
      var count = this.length;

      if (count === -1) {
        count = reader.readValue().toNumber();
      }

      var coders = [];

      for (var i = 0; i < count; i++) {
        coders.push(new AnonymousCoder(this.coder));
      }

      return reader.coerce(this.name, unpack(reader, coders));
    }
  }]);

  return ArrayCoder;
}(Coder);