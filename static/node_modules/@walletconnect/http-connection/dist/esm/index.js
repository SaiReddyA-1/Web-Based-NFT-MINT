import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import _inherits from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/inherits";
import _possibleConstructorReturn from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/possibleConstructorReturn";
import _getPrototypeOf from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/getPrototypeOf";

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

import EventEmitter from "eventemitter3";
import { XMLHttpRequest } from "xhr2-cookies";
import { getFromWindow } from "@walletconnect/utils";
var XHR = getFromWindow("XMLHttpRequest") || XMLHttpRequest;

var HTTPConnection = /*#__PURE__*/function (_EventEmitter) {
  _inherits(HTTPConnection, _EventEmitter);

  var _super = _createSuper(HTTPConnection);

  function HTTPConnection(url) {
    var _this;

    _classCallCheck(this, HTTPConnection);

    _this = _super.call(this);
    _this.url = url;
    return _this;
  }

  _createClass(HTTPConnection, [{
    key: "formatError",
    value: function formatError(payload, message) {
      var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
      return {
        error: {
          message: message,
          code: code
        },
        id: payload.id,
        jsonrpc: payload.jsonrpc
      };
    }
  }, {
    key: "send",
    value: function send(payload, internal) {
      var _this2 = this;

      return new Promise(function (resolve) {
        if (payload.method === "eth_subscribe") {
          var error = _this2.formatError(payload, "Subscriptions are not supported by this HTTP endpoint");

          _this2.emit("error", error);

          return resolve(error);
        }

        var xhr = new XHR();
        var responded = false;

        var res = function res(err, result) {
          if (!responded) {
            xhr.abort();
            responded = true;

            if (internal) {
              internal(err, result);
            } else {
              var id = payload.id,
                  jsonrpc = payload.jsonrpc;
              var response = err ? {
                id: id,
                jsonrpc: jsonrpc,
                error: {
                  message: err.message,
                  code: err.code
                }
              } : {
                id: id,
                jsonrpc: jsonrpc,
                result: result
              };

              _this2.emit("payload", response);

              resolve(response);
            }
          }
        };

        xhr.open("POST", _this2.url, true);
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.timeout = 60 * 1000;
        xhr.onerror = res;
        xhr.ontimeout = res;

        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            try {
              var response = JSON.parse(xhr.responseText);
              res(response.error, response.result);
            } catch (e) {
              res(e);
            }
          }
        };

        xhr.send(JSON.stringify(payload));
      });
    }
  }]);

  return HTTPConnection;
}(EventEmitter);

export default HTTPConnection;