import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";
import _asyncToGenerator from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/asyncToGenerator";
import * as crypto from "@walletconnect/crypto";
import * as encoding from "@walletconnect/encoding";
import { convertArrayBufferToBuffer, convertBufferToArrayBuffer } from "@walletconnect/utils";
export function generateKey(_x) {
  return _generateKey.apply(this, arguments);
}

function _generateKey() {
  _generateKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(length) {
    var _length, bytes, result;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _length = (length || 256) / 8;
            bytes = crypto.randomBytes(_length);
            result = convertBufferToArrayBuffer(encoding.arrayToBuffer(bytes));
            return _context.abrupt("return", result);

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _generateKey.apply(this, arguments);
}

export function verifyHmac(_x2, _x3) {
  return _verifyHmac.apply(this, arguments);
}

function _verifyHmac() {
  _verifyHmac = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(payload, key) {
    var cipherText, iv, hmac, hmacHex, unsigned, chmac, chmacHex;
    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            cipherText = encoding.hexToArray(payload.data);
            iv = encoding.hexToArray(payload.iv);
            hmac = encoding.hexToArray(payload.hmac);
            hmacHex = encoding.arrayToHex(hmac, false);
            unsigned = encoding.concatArrays(cipherText, iv);
            _context2.next = 7;
            return crypto.hmacSha256Sign(key, unsigned);

          case 7:
            chmac = _context2.sent;
            chmacHex = encoding.arrayToHex(chmac, false);

            if (!(encoding.removeHexPrefix(hmacHex) === encoding.removeHexPrefix(chmacHex))) {
              _context2.next = 11;
              break;
            }

            return _context2.abrupt("return", true);

          case 11:
            return _context2.abrupt("return", false);

          case 12:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _verifyHmac.apply(this, arguments);
}

export function encrypt(_x4, _x5, _x6) {
  return _encrypt.apply(this, arguments);
}

function _encrypt() {
  _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(data, key, providedIv) {
    var _key, ivArrayBuffer, iv, ivHex, contentString, content, cipherText, cipherTextHex, unsigned, hmac, hmacHex;

    return _regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));
            _context3.t0 = providedIv;

            if (_context3.t0) {
              _context3.next = 6;
              break;
            }

            _context3.next = 5;
            return generateKey(128);

          case 5:
            _context3.t0 = _context3.sent;

          case 6:
            ivArrayBuffer = _context3.t0;
            iv = encoding.bufferToArray(convertArrayBufferToBuffer(ivArrayBuffer));
            ivHex = encoding.arrayToHex(iv, false);
            contentString = JSON.stringify(data);
            content = encoding.utf8ToArray(contentString);
            _context3.next = 13;
            return crypto.aesCbcEncrypt(iv, _key, content);

          case 13:
            cipherText = _context3.sent;
            cipherTextHex = encoding.arrayToHex(cipherText, false);
            unsigned = encoding.concatArrays(cipherText, iv);
            _context3.next = 18;
            return crypto.hmacSha256Sign(_key, unsigned);

          case 18:
            hmac = _context3.sent;
            hmacHex = encoding.arrayToHex(hmac, false);
            return _context3.abrupt("return", {
              data: cipherTextHex,
              hmac: hmacHex,
              iv: ivHex
            });

          case 21:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _encrypt.apply(this, arguments);
}

export function decrypt(_x7, _x8) {
  return _decrypt.apply(this, arguments);
}

function _decrypt() {
  _decrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(payload, key) {
    var _key, verified, cipherText, iv, buffer, utf8, data;

    return _regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _key = encoding.bufferToArray(convertArrayBufferToBuffer(key));

            if (_key) {
              _context4.next = 3;
              break;
            }

            throw new Error("Missing key: required for decryption");

          case 3:
            _context4.next = 5;
            return verifyHmac(payload, _key);

          case 5:
            verified = _context4.sent;

            if (verified) {
              _context4.next = 8;
              break;
            }

            return _context4.abrupt("return", null);

          case 8:
            cipherText = encoding.hexToArray(payload.data);
            iv = encoding.hexToArray(payload.iv);
            _context4.next = 12;
            return crypto.aesCbcDecrypt(iv, _key, cipherText);

          case 12:
            buffer = _context4.sent;
            utf8 = encoding.arrayToUtf8(buffer);
            _context4.prev = 14;
            data = JSON.parse(utf8);
            _context4.next = 21;
            break;

          case 18:
            _context4.prev = 18;
            _context4.t0 = _context4["catch"](14);
            return _context4.abrupt("return", null);

          case 21:
            return _context4.abrupt("return", data);

          case 22:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[14, 18]]);
  }));
  return _decrypt.apply(this, arguments);
}