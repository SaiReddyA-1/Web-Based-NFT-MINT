import _regeneratorRuntime from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/regenerator";
import _asyncToGenerator from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/asyncToGenerator";
import _toConsumableArray from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/toConsumableArray";
import _classCallCheck from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/classCallCheck";
import _createClass from "C:\\Users\\GridComputers\\Downloads\\111\\111\\node_modules\\babel-preset-react-app\\node_modules\\@babel\\runtime/helpers/esm/createClass";
import { parsePersonalSign, parseTransactionData, convertArrayBufferToHex, convertHexToArrayBuffer, getClientMeta, payloadId, uuid, formatRpcError, parseWalletConnectUri, convertNumberToHex, isJsonRpcResponseSuccess, isJsonRpcResponseError, isSilentPayload, getLocal, signingMethods, mobileLinkChoiceKey, isMobile, removeLocal } from "@walletconnect/utils";
import SocketTransport from "@walletconnect/socket-transport";
import { ERROR_SESSION_CONNECTED, ERROR_SESSION_DISCONNECTED, ERROR_SESSION_REJECTED, ERROR_MISSING_JSON_RPC, ERROR_MISSING_RESULT, ERROR_MISSING_ERROR, ERROR_MISSING_METHOD, ERROR_MISSING_ID, ERROR_INVALID_RESPONSE, ERROR_INVALID_URI, ERROR_MISSING_REQUIRED, ERROR_QRCODE_MODAL_NOT_PROVIDED, ERROR_QRCODE_MODAL_USER_CLOSED } from "./errors";
import EventManager from "./events";
import SessionStorage from "./storage";
import { getBridgeUrl } from "./url";

var Connector = /*#__PURE__*/function () {
  function Connector(opts) {
    _classCallCheck(this, Connector);

    this.protocol = "wc";
    this.version = 1;
    this._bridge = "";
    this._key = null;
    this._clientId = "";
    this._clientMeta = null;
    this._peerId = "";
    this._peerMeta = null;
    this._handshakeId = 0;
    this._handshakeTopic = "";
    this._connected = false;
    this._accounts = [];
    this._chainId = 0;
    this._networkId = 0;
    this._rpcUrl = "";
    this._eventManager = new EventManager();
    this._clientMeta = getClientMeta() || opts.connectorOpts.clientMeta || null;
    this._cryptoLib = opts.cryptoLib;
    this._sessionStorage = opts.sessionStorage || new SessionStorage(opts.connectorOpts.storageId);
    this._qrcodeModal = opts.connectorOpts.qrcodeModal;
    this._qrcodeModalOptions = opts.connectorOpts.qrcodeModalOptions;
    this._signingMethods = [].concat(_toConsumableArray(signingMethods), _toConsumableArray(opts.connectorOpts.signingMethods || []));

    if (!opts.connectorOpts.bridge && !opts.connectorOpts.uri && !opts.connectorOpts.session) {
      throw new Error(ERROR_MISSING_REQUIRED);
    }

    if (opts.connectorOpts.bridge) {
      this.bridge = getBridgeUrl(opts.connectorOpts.bridge);
    }

    if (opts.connectorOpts.uri) {
      this.uri = opts.connectorOpts.uri;
    }

    var session = opts.connectorOpts.session || this._getStorageSession();

    if (session) {
      this.session = session;
    }

    if (this.handshakeId) {
      this._subscribeToSessionResponse(this.handshakeId, "Session request rejected");
    }

    this._transport = opts.transport || new SocketTransport({
      protocol: this.protocol,
      version: this.version,
      url: this.bridge,
      subscriptions: [this.clientId]
    });

    this._subscribeToInternalEvents();

    this._initTransport();

    if (opts.connectorOpts.uri) {
      this._subscribeToSessionRequest();
    }

    if (opts.pushServerOpts) {
      this._registerPushServer(opts.pushServerOpts);
    }
  }

  _createClass(Connector, [{
    key: "bridge",
    get: function get() {
      return this._bridge;
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      this._bridge = value;
    }
  }, {
    key: "key",
    get: function get() {
      if (this._key) {
        var key = convertArrayBufferToHex(this._key, true);
        return key;
      }

      return "";
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      var key = convertHexToArrayBuffer(value);
      this._key = key;
    }
  }, {
    key: "clientId",
    get: function get() {
      var clientId = this._clientId;

      if (!clientId) {
        clientId = this._clientId = uuid();
      }

      return this._clientId;
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      this._clientId = value;
    }
  }, {
    key: "peerId",
    get: function get() {
      return this._peerId;
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      this._peerId = value;
    }
  }, {
    key: "clientMeta",
    get: function get() {
      var clientMeta = this._clientMeta;

      if (!clientMeta) {
        clientMeta = this._clientMeta = getClientMeta();
      }

      return clientMeta;
    },
    set: function set(value) {}
  }, {
    key: "peerMeta",
    get: function get() {
      var peerMeta = this._peerMeta;
      return peerMeta;
    },
    set: function set(value) {
      this._peerMeta = value;
    }
  }, {
    key: "handshakeTopic",
    get: function get() {
      return this._handshakeTopic;
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      this._handshakeTopic = value;
    }
  }, {
    key: "handshakeId",
    get: function get() {
      return this._handshakeId;
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      this._handshakeId = value;
    }
  }, {
    key: "uri",
    get: function get() {
      var _uri = this._formatUri();

      return _uri;
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      var _this$_parseUri = this._parseUri(value),
          handshakeTopic = _this$_parseUri.handshakeTopic,
          bridge = _this$_parseUri.bridge,
          key = _this$_parseUri.key;

      this.handshakeTopic = handshakeTopic;
      this.bridge = bridge;
      this.key = key;
    }
  }, {
    key: "chainId",
    get: function get() {
      var chainId = this._chainId;
      return chainId;
    },
    set: function set(value) {
      this._chainId = value;
    }
  }, {
    key: "networkId",
    get: function get() {
      var networkId = this._networkId;
      return networkId;
    },
    set: function set(value) {
      this._networkId = value;
    }
  }, {
    key: "accounts",
    get: function get() {
      var accounts = this._accounts;
      return accounts;
    },
    set: function set(value) {
      this._accounts = value;
    }
  }, {
    key: "rpcUrl",
    get: function get() {
      var rpcUrl = this._rpcUrl;
      return rpcUrl;
    },
    set: function set(value) {
      this._rpcUrl = value;
    }
  }, {
    key: "connected",
    get: function get() {
      return this._connected;
    },
    set: function set(value) {}
  }, {
    key: "pending",
    get: function get() {
      return !!this._handshakeTopic;
    },
    set: function set(value) {}
  }, {
    key: "session",
    get: function get() {
      return {
        connected: this.connected,
        accounts: this.accounts,
        chainId: this.chainId,
        bridge: this.bridge,
        key: this.key,
        clientId: this.clientId,
        clientMeta: this.clientMeta,
        peerId: this.peerId,
        peerMeta: this.peerMeta,
        handshakeId: this.handshakeId,
        handshakeTopic: this.handshakeTopic
      };
    },
    set: function set(value) {
      if (!value) {
        return;
      }

      this._connected = value.connected;
      this.accounts = value.accounts;
      this.chainId = value.chainId;
      this.bridge = value.bridge;
      this.key = value.key;
      this.clientId = value.clientId;
      this.clientMeta = value.clientMeta;
      this.peerId = value.peerId;
      this.peerMeta = value.peerMeta;
      this.handshakeId = value.handshakeId;
      this.handshakeTopic = value.handshakeTopic;
    }
  }, {
    key: "on",
    value: function on(event, callback) {
      var eventEmitter = {
        event: event,
        callback: callback
      };

      this._eventManager.subscribe(eventEmitter);
    }
  }, {
    key: "off",
    value: function off(event) {
      this._eventManager.unsubscribe(event);
    }
  }, {
    key: "createInstantRequest",
    value: function () {
      var _createInstantRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(instantRequest) {
        var _this = this;

        var request, endInstantRequest, result;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this._generateKey();

              case 2:
                this._key = _context.sent;
                request = this._formatRequest({
                  method: "wc_instantRequest",
                  params: [{
                    peerId: this.clientId,
                    peerMeta: this.clientMeta,
                    request: this._formatRequest(instantRequest)
                  }]
                });
                this.handshakeId = request.id;
                this.handshakeTopic = uuid();

                this._eventManager.trigger({
                  event: "display_uri",
                  params: [this.uri]
                });

                this.on("modal_closed", function () {
                  throw new Error(ERROR_QRCODE_MODAL_USER_CLOSED);
                });

                endInstantRequest = function endInstantRequest() {
                  _this.killSession();
                };

                _context.prev = 9;
                _context.next = 12;
                return this._sendCallRequest(request);

              case 12:
                result = _context.sent;

                if (result) {
                  endInstantRequest();
                }

                return _context.abrupt("return", result);

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](9);
                endInstantRequest();
                throw _context.t0;

              case 21:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[9, 17]]);
      }));

      function createInstantRequest(_x) {
        return _createInstantRequest.apply(this, arguments);
      }

      return createInstantRequest;
    }()
  }, {
    key: "connect",
    value: function () {
      var _connect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3(opts) {
        var _this2 = this;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (this._qrcodeModal) {
                  _context3.next = 2;
                  break;
                }

                throw new Error(ERROR_QRCODE_MODAL_NOT_PROVIDED);

              case 2:
                if (!this.connected) {
                  _context3.next = 4;
                  break;
                }

                return _context3.abrupt("return", {
                  chainId: this.chainId,
                  accounts: this.accounts
                });

              case 4:
                _context3.next = 6;
                return this.createSession(opts);

              case 6:
                return _context3.abrupt("return", new Promise( /*#__PURE__*/function () {
                  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(resolve, reject) {
                    return _regeneratorRuntime.wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _this2.on("modal_closed", function () {
                              return reject(new Error(ERROR_QRCODE_MODAL_USER_CLOSED));
                            });

                            _this2.on("connect", function (error, payload) {
                              if (error) {
                                return reject(error);
                              }

                              resolve(payload.params[0]);
                            });

                          case 2:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x3, _x4) {
                    return _ref.apply(this, arguments);
                  };
                }()));

              case 7:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function connect(_x2) {
        return _connect.apply(this, arguments);
      }

      return connect;
    }()
  }, {
    key: "createSession",
    value: function () {
      var _createSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(opts) {
        var request;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                if (!this._connected) {
                  _context4.next = 2;
                  break;
                }

                throw new Error(ERROR_SESSION_CONNECTED);

              case 2:
                if (!this.pending) {
                  _context4.next = 4;
                  break;
                }

                return _context4.abrupt("return");

              case 4:
                _context4.next = 6;
                return this._generateKey();

              case 6:
                this._key = _context4.sent;
                request = this._formatRequest({
                  method: "wc_sessionRequest",
                  params: [{
                    peerId: this.clientId,
                    peerMeta: this.clientMeta,
                    chainId: opts && opts.chainId ? opts.chainId : null
                  }]
                });
                this.handshakeId = request.id;
                this.handshakeTopic = uuid();

                this._sendSessionRequest(request, "Session update rejected", {
                  topic: this.handshakeTopic
                });

                this._eventManager.trigger({
                  event: "display_uri",
                  params: [this.uri]
                });

              case 12:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function createSession(_x5) {
        return _createSession.apply(this, arguments);
      }

      return createSession;
    }()
  }, {
    key: "approveSession",
    value: function approveSession(sessionStatus) {
      if (this._connected) {
        throw new Error(ERROR_SESSION_CONNECTED);
      }

      this.chainId = sessionStatus.chainId;
      this.accounts = sessionStatus.accounts;
      this.networkId = sessionStatus.networkId || 0;
      this.rpcUrl = sessionStatus.rpcUrl || "";
      var sessionParams = {
        approved: true,
        chainId: this.chainId,
        networkId: this.networkId,
        accounts: this.accounts,
        rpcUrl: this.rpcUrl,
        peerId: this.clientId,
        peerMeta: this.clientMeta
      };
      var response = {
        id: this.handshakeId,
        jsonrpc: "2.0",
        result: sessionParams
      };

      this._sendResponse(response);

      this._connected = true;

      this._setStorageSession();

      this._eventManager.trigger({
        event: "connect",
        params: [{
          peerId: this.peerId,
          peerMeta: this.peerMeta,
          chainId: this.chainId,
          accounts: this.accounts
        }]
      });
    }
  }, {
    key: "rejectSession",
    value: function rejectSession(sessionError) {
      if (this._connected) {
        throw new Error(ERROR_SESSION_CONNECTED);
      }

      var message = sessionError && sessionError.message ? sessionError.message : ERROR_SESSION_REJECTED;

      var response = this._formatResponse({
        id: this.handshakeId,
        error: {
          message: message
        }
      });

      this._sendResponse(response);

      this._connected = false;

      this._eventManager.trigger({
        event: "disconnect",
        params: [{
          message: message
        }]
      });

      this._removeStorageSession();
    }
  }, {
    key: "updateSession",
    value: function updateSession(sessionStatus) {
      if (!this._connected) {
        throw new Error(ERROR_SESSION_DISCONNECTED);
      }

      this.chainId = sessionStatus.chainId;
      this.accounts = sessionStatus.accounts;
      this.networkId = sessionStatus.networkId || 0;
      this.rpcUrl = sessionStatus.rpcUrl || "";
      var sessionParams = {
        approved: true,
        chainId: this.chainId,
        networkId: this.networkId,
        accounts: this.accounts,
        rpcUrl: this.rpcUrl
      };

      var request = this._formatRequest({
        method: "wc_sessionUpdate",
        params: [sessionParams]
      });

      this._sendSessionRequest(request, "Session update rejected");

      this._eventManager.trigger({
        event: "session_update",
        params: [{
          chainId: this.chainId,
          accounts: this.accounts
        }]
      });

      this._manageStorageSession();
    }
  }, {
    key: "killSession",
    value: function () {
      var _killSession = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(sessionError) {
        var message, sessionParams, request;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                message = sessionError ? sessionError.message : "Session Disconnected";
                sessionParams = {
                  approved: false,
                  chainId: null,
                  networkId: null,
                  accounts: null
                };
                request = this._formatRequest({
                  method: "wc_sessionUpdate",
                  params: [sessionParams]
                });
                _context5.next = 5;
                return this._sendRequest(request);

              case 5:
                this._handleSessionDisconnect(message);

              case 6:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function killSession(_x6) {
        return _killSession.apply(this, arguments);
      }

      return killSession;
    }()
  }, {
    key: "sendTransaction",
    value: function () {
      var _sendTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(tx) {
        var parsedTx, request, result;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                if (this._connected) {
                  _context6.next = 2;
                  break;
                }

                throw new Error(ERROR_SESSION_DISCONNECTED);

              case 2:
                parsedTx = parseTransactionData(tx);
                request = this._formatRequest({
                  method: "eth_sendTransaction",
                  params: [parsedTx]
                });
                _context6.next = 6;
                return this._sendCallRequest(request);

              case 6:
                result = _context6.sent;
                return _context6.abrupt("return", result);

              case 8:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, this);
      }));

      function sendTransaction(_x7) {
        return _sendTransaction.apply(this, arguments);
      }

      return sendTransaction;
    }()
  }, {
    key: "signTransaction",
    value: function () {
      var _signTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(tx) {
        var parsedTx, request, result;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                if (this._connected) {
                  _context7.next = 2;
                  break;
                }

                throw new Error(ERROR_SESSION_DISCONNECTED);

              case 2:
                parsedTx = parseTransactionData(tx);
                request = this._formatRequest({
                  method: "eth_signTransaction",
                  params: [parsedTx]
                });
                _context7.next = 6;
                return this._sendCallRequest(request);

              case 6:
                result = _context7.sent;
                return _context7.abrupt("return", result);

              case 8:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7, this);
      }));

      function signTransaction(_x8) {
        return _signTransaction.apply(this, arguments);
      }

      return signTransaction;
    }()
  }, {
    key: "signMessage",
    value: function () {
      var _signMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(params) {
        var request, result;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                if (this._connected) {
                  _context8.next = 2;
                  break;
                }

                throw new Error(ERROR_SESSION_DISCONNECTED);

              case 2:
                request = this._formatRequest({
                  method: "eth_sign",
                  params: params
                });
                _context8.next = 5;
                return this._sendCallRequest(request);

              case 5:
                result = _context8.sent;
                return _context8.abrupt("return", result);

              case 7:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function signMessage(_x9) {
        return _signMessage.apply(this, arguments);
      }

      return signMessage;
    }()
  }, {
    key: "signPersonalMessage",
    value: function () {
      var _signPersonalMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9(params) {
        var request, result;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (this._connected) {
                  _context9.next = 2;
                  break;
                }

                throw new Error(ERROR_SESSION_DISCONNECTED);

              case 2:
                params = parsePersonalSign(params);
                request = this._formatRequest({
                  method: "personal_sign",
                  params: params
                });
                _context9.next = 6;
                return this._sendCallRequest(request);

              case 6:
                result = _context9.sent;
                return _context9.abrupt("return", result);

              case 8:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function signPersonalMessage(_x10) {
        return _signPersonalMessage.apply(this, arguments);
      }

      return signPersonalMessage;
    }()
  }, {
    key: "signTypedData",
    value: function () {
      var _signTypedData = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10(params) {
        var request, result;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                if (this._connected) {
                  _context10.next = 2;
                  break;
                }

                throw new Error(ERROR_SESSION_DISCONNECTED);

              case 2:
                request = this._formatRequest({
                  method: "eth_signTypedData",
                  params: params
                });
                _context10.next = 5;
                return this._sendCallRequest(request);

              case 5:
                result = _context10.sent;
                return _context10.abrupt("return", result);

              case 7:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function signTypedData(_x11) {
        return _signTypedData.apply(this, arguments);
      }

      return signTypedData;
    }()
  }, {
    key: "updateChain",
    value: function () {
      var _updateChain = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11(chainParams) {
        var request, result;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                if (this._connected) {
                  _context11.next = 2;
                  break;
                }

                throw new Error("Session currently disconnected");

              case 2:
                request = this._formatRequest({
                  method: "wallet_updateChain",
                  params: [chainParams]
                });
                _context11.next = 5;
                return this._sendCallRequest(request);

              case 5:
                result = _context11.sent;
                return _context11.abrupt("return", result);

              case 7:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11, this);
      }));

      function updateChain(_x12) {
        return _updateChain.apply(this, arguments);
      }

      return updateChain;
    }()
  }, {
    key: "unsafeSend",
    value: function unsafeSend(request, options) {
      var _this3 = this;

      this._sendRequest(request, options);

      this._eventManager.trigger({
        event: "call_request_sent",
        params: [{
          request: request,
          options: options
        }]
      });

      return new Promise(function (resolve, reject) {
        _this3._subscribeToResponse(request.id, function (error, payload) {
          if (error) {
            reject(error);
            return;
          }

          if (!payload) {
            throw new Error(ERROR_MISSING_JSON_RPC);
          }

          resolve(payload);
        });
      });
    }
  }, {
    key: "sendCustomRequest",
    value: function () {
      var _sendCustomRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12(request, options) {
        var formattedRequest, result;
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                if (this._connected) {
                  _context12.next = 2;
                  break;
                }

                throw new Error(ERROR_SESSION_DISCONNECTED);

              case 2:
                _context12.t0 = request.method;
                _context12.next = _context12.t0 === "eth_accounts" ? 5 : _context12.t0 === "eth_chainId" ? 6 : _context12.t0 === "eth_sendTransaction" ? 7 : _context12.t0 === "eth_signTransaction" ? 7 : _context12.t0 === "personal_sign" ? 9 : 11;
                break;

              case 5:
                return _context12.abrupt("return", this.accounts);

              case 6:
                return _context12.abrupt("return", convertNumberToHex(this.chainId));

              case 7:
                if (request.params) {
                  request.params[0] = parseTransactionData(request.params[0]);
                }

                return _context12.abrupt("break", 12);

              case 9:
                if (request.params) {
                  request.params = parsePersonalSign(request.params);
                }

                return _context12.abrupt("break", 12);

              case 11:
                return _context12.abrupt("break", 12);

              case 12:
                formattedRequest = this._formatRequest(request);
                _context12.next = 15;
                return this._sendCallRequest(formattedRequest, options);

              case 15:
                result = _context12.sent;
                return _context12.abrupt("return", result);

              case 17:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function sendCustomRequest(_x13, _x14) {
        return _sendCustomRequest.apply(this, arguments);
      }

      return sendCustomRequest;
    }()
  }, {
    key: "approveRequest",
    value: function approveRequest(response) {
      if (isJsonRpcResponseSuccess(response)) {
        var formattedResponse = this._formatResponse(response);

        this._sendResponse(formattedResponse);
      } else {
        throw new Error(ERROR_MISSING_RESULT);
      }
    }
  }, {
    key: "rejectRequest",
    value: function rejectRequest(response) {
      if (isJsonRpcResponseError(response)) {
        var formattedResponse = this._formatResponse(response);

        this._sendResponse(formattedResponse);
      } else {
        throw new Error(ERROR_MISSING_ERROR);
      }
    }
  }, {
    key: "transportClose",
    value: function transportClose() {
      this._transport.close();
    }
  }, {
    key: "_sendRequest",
    value: function () {
      var _sendRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13(request, options) {
        var callRequest, encryptionPayload, topic, payload, silent;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                callRequest = this._formatRequest(request);
                _context13.next = 3;
                return this._encrypt(callRequest);

              case 3:
                encryptionPayload = _context13.sent;
                topic = typeof (options === null || options === void 0 ? void 0 : options.topic) !== "undefined" ? options.topic : this.peerId;
                payload = JSON.stringify(encryptionPayload);
                silent = typeof (options === null || options === void 0 ? void 0 : options.forcePushNotification) !== "undefined" ? !options.forcePushNotification : isSilentPayload(callRequest);

                this._transport.send(payload, topic, silent);

              case 8:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function _sendRequest(_x15, _x16) {
        return _sendRequest2.apply(this, arguments);
      }

      return _sendRequest;
    }()
  }, {
    key: "_sendResponse",
    value: function () {
      var _sendResponse2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14(response) {
        var encryptionPayload, topic, payload, silent;
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return this._encrypt(response);

              case 2:
                encryptionPayload = _context14.sent;
                topic = this.peerId;
                payload = JSON.stringify(encryptionPayload);
                silent = true;

                this._transport.send(payload, topic, silent);

              case 7:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function _sendResponse(_x17) {
        return _sendResponse2.apply(this, arguments);
      }

      return _sendResponse;
    }()
  }, {
    key: "_sendSessionRequest",
    value: function () {
      var _sendSessionRequest2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15(request, errorMsg, options) {
        return _regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                this._sendRequest(request, options);

                this._subscribeToSessionResponse(request.id, errorMsg);

              case 2:
              case "end":
                return _context15.stop();
            }
          }
        }, _callee15, this);
      }));

      function _sendSessionRequest(_x18, _x19, _x20) {
        return _sendSessionRequest2.apply(this, arguments);
      }

      return _sendSessionRequest;
    }()
  }, {
    key: "_sendCallRequest",
    value: function _sendCallRequest(request, options) {
      this._sendRequest(request, options);

      this._eventManager.trigger({
        event: "call_request_sent",
        params: [{
          request: request,
          options: options
        }]
      });

      return this._subscribeToCallResponse(request.id);
    }
  }, {
    key: "_formatRequest",
    value: function _formatRequest(request) {
      if (typeof request.method === "undefined") {
        throw new Error(ERROR_MISSING_METHOD);
      }

      var formattedRequest = {
        id: typeof request.id === "undefined" ? payloadId() : request.id,
        jsonrpc: "2.0",
        method: request.method,
        params: typeof request.params === "undefined" ? [] : request.params
      };
      return formattedRequest;
    }
  }, {
    key: "_formatResponse",
    value: function _formatResponse(response) {
      if (typeof response.id === "undefined") {
        throw new Error(ERROR_MISSING_ID);
      }

      var baseResponse = {
        id: response.id,
        jsonrpc: "2.0"
      };

      if (isJsonRpcResponseError(response)) {
        var error = formatRpcError(response.error);
        var errorResponse = Object.assign(Object.assign(Object.assign({}, baseResponse), response), {
          error: error
        });
        return errorResponse;
      } else if (isJsonRpcResponseSuccess(response)) {
        var successResponse = Object.assign(Object.assign({}, baseResponse), response);
        return successResponse;
      }

      throw new Error(ERROR_INVALID_RESPONSE);
    }
  }, {
    key: "_handleSessionDisconnect",
    value: function _handleSessionDisconnect(errorMsg) {
      var message = errorMsg || "Session Disconnected";

      if (!this._connected) {
        if (this._qrcodeModal) {
          this._qrcodeModal.close();
        }

        removeLocal(mobileLinkChoiceKey);
      }

      if (this._connected) {
        this._connected = false;
      }

      if (this._handshakeId) {
        this._handshakeId = 0;
      }

      if (this._handshakeTopic) {
        this._handshakeTopic = "";
      }

      if (this._peerId) {
        this._peerId = "";
      }

      this._eventManager.trigger({
        event: "disconnect",
        params: [{
          message: message
        }]
      });

      this._removeStorageSession();

      this.transportClose();
    }
  }, {
    key: "_handleSessionResponse",
    value: function _handleSessionResponse(errorMsg, sessionParams) {
      if (sessionParams) {
        if (sessionParams.approved) {
          if (!this._connected) {
            this._connected = true;

            if (sessionParams.chainId) {
              this.chainId = sessionParams.chainId;
            }

            if (sessionParams.accounts) {
              this.accounts = sessionParams.accounts;
            }

            if (sessionParams.peerId && !this.peerId) {
              this.peerId = sessionParams.peerId;
            }

            if (sessionParams.peerMeta && !this.peerMeta) {
              this.peerMeta = sessionParams.peerMeta;
            }

            this._eventManager.trigger({
              event: "connect",
              params: [{
                peerId: this.peerId,
                peerMeta: this.peerMeta,
                chainId: this.chainId,
                accounts: this.accounts
              }]
            });
          } else {
            if (sessionParams.chainId) {
              this.chainId = sessionParams.chainId;
            }

            if (sessionParams.accounts) {
              this.accounts = sessionParams.accounts;
            }

            this._eventManager.trigger({
              event: "session_update",
              params: [{
                chainId: this.chainId,
                accounts: this.accounts
              }]
            });
          }

          this._manageStorageSession();
        } else {
          this._handleSessionDisconnect(errorMsg);
        }
      } else {
        this._handleSessionDisconnect(errorMsg);
      }
    }
  }, {
    key: "_handleIncomingMessages",
    value: function () {
      var _handleIncomingMessages2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee16(socketMessage) {
        var activeTopics, encryptionPayload, payload;
        return _regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                activeTopics = [this.clientId, this.handshakeTopic];

                if (activeTopics.includes(socketMessage.topic)) {
                  _context16.next = 3;
                  break;
                }

                return _context16.abrupt("return");

              case 3:
                _context16.prev = 3;
                encryptionPayload = JSON.parse(socketMessage.payload);
                _context16.next = 10;
                break;

              case 7:
                _context16.prev = 7;
                _context16.t0 = _context16["catch"](3);
                return _context16.abrupt("return");

              case 10:
                _context16.next = 12;
                return this._decrypt(encryptionPayload);

              case 12:
                payload = _context16.sent;

                if (payload) {
                  this._eventManager.trigger(payload);
                }

              case 14:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this, [[3, 7]]);
      }));

      function _handleIncomingMessages(_x21) {
        return _handleIncomingMessages2.apply(this, arguments);
      }

      return _handleIncomingMessages;
    }()
  }, {
    key: "_subscribeToSessionRequest",
    value: function _subscribeToSessionRequest() {
      this._transport.subscribe(this.handshakeTopic);
    }
  }, {
    key: "_subscribeToResponse",
    value: function _subscribeToResponse(id, callback) {
      this.on("response:".concat(id), callback);
    }
  }, {
    key: "_subscribeToSessionResponse",
    value: function _subscribeToSessionResponse(id, errorMsg) {
      var _this4 = this;

      this._subscribeToResponse(id, function (error, payload) {
        if (error) {
          _this4._handleSessionResponse(error.message);

          return;
        }

        if (isJsonRpcResponseSuccess(payload)) {
          _this4._handleSessionResponse(errorMsg, payload.result);
        } else if (payload.error && payload.error.message) {
          _this4._handleSessionResponse(payload.error.message);
        } else {
          _this4._handleSessionResponse(errorMsg);
        }
      });
    }
  }, {
    key: "_subscribeToCallResponse",
    value: function _subscribeToCallResponse(id) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        _this5._subscribeToResponse(id, function (error, payload) {
          if (error) {
            reject(error);
            return;
          }

          if (isJsonRpcResponseSuccess(payload)) {
            resolve(payload.result);
          } else if (payload.error && payload.error.message) {
            reject(new Error(payload.error.message));
          } else {
            reject(new Error(ERROR_INVALID_RESPONSE));
          }
        });
      });
    }
  }, {
    key: "_subscribeToInternalEvents",
    value: function _subscribeToInternalEvents() {
      var _this6 = this;

      this.on("display_uri", function () {
        if (_this6._qrcodeModal) {
          _this6._qrcodeModal.open(_this6.uri, function () {
            _this6._eventManager.trigger({
              event: "modal_closed",
              params: []
            });
          }, _this6._qrcodeModalOptions);
        }
      });
      this.on("connect", function () {
        if (_this6._qrcodeModal) {
          _this6._qrcodeModal.close();
        }
      });
      this.on("call_request_sent", function (error, payload) {
        var request = payload.params[0].request;

        if (isMobile() && _this6._signingMethods.includes(request.method)) {
          var mobileLinkUrl = getLocal(mobileLinkChoiceKey);

          if (mobileLinkUrl) {
            window.location.href = mobileLinkUrl.href;
          }
        }
      });
      this.on("wc_sessionRequest", function (error, payload) {
        if (error) {
          _this6._eventManager.trigger({
            event: "error",
            params: [{
              code: "SESSION_REQUEST_ERROR",
              message: error.toString()
            }]
          });
        }

        _this6.handshakeId = payload.id;
        _this6.peerId = payload.params[0].peerId;
        _this6.peerMeta = payload.params[0].peerMeta;
        var internalPayload = Object.assign(Object.assign({}, payload), {
          method: "session_request"
        });

        _this6._eventManager.trigger(internalPayload);
      });
      this.on("wc_sessionUpdate", function (error, payload) {
        if (error) {
          _this6._handleSessionResponse(error.message);
        }

        _this6._handleSessionResponse("Session disconnected", payload.params[0]);
      });
    }
  }, {
    key: "_initTransport",
    value: function _initTransport() {
      var _this7 = this;

      this._transport.on("message", function (socketMessage) {
        return _this7._handleIncomingMessages(socketMessage);
      });

      this._transport.on("open", function () {
        return _this7._eventManager.trigger({
          event: "transport_open",
          params: []
        });
      });

      this._transport.on("close", function () {
        return _this7._eventManager.trigger({
          event: "transport_close",
          params: []
        });
      });

      this._transport.on("error", function () {
        return _this7._eventManager.trigger({
          event: "transport_error",
          params: ["Websocket connection failed"]
        });
      });

      this._transport.open();
    }
  }, {
    key: "_formatUri",
    value: function _formatUri() {
      var protocol = this.protocol;
      var handshakeTopic = this.handshakeTopic;
      var version = this.version;
      var bridge = encodeURIComponent(this.bridge);
      var key = this.key;
      var uri = "".concat(protocol, ":").concat(handshakeTopic, "@").concat(version, "?bridge=").concat(bridge, "&key=").concat(key);
      return uri;
    }
  }, {
    key: "_parseUri",
    value: function _parseUri(uri) {
      var result = parseWalletConnectUri(uri);

      if (result.protocol === this.protocol) {
        if (!result.handshakeTopic) {
          throw Error("Invalid or missing handshakeTopic parameter value");
        }

        var handshakeTopic = result.handshakeTopic;

        if (!result.bridge) {
          throw Error("Invalid or missing bridge url parameter value");
        }

        var bridge = decodeURIComponent(result.bridge);

        if (!result.key) {
          throw Error("Invalid or missing key parameter value");
        }

        var key = result.key;
        return {
          handshakeTopic: handshakeTopic,
          bridge: bridge,
          key: key
        };
      } else {
        throw new Error(ERROR_INVALID_URI);
      }
    }
  }, {
    key: "_generateKey",
    value: function () {
      var _generateKey2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee17() {
        var result;
        return _regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                if (!this._cryptoLib) {
                  _context17.next = 5;
                  break;
                }

                _context17.next = 3;
                return this._cryptoLib.generateKey();

              case 3:
                result = _context17.sent;
                return _context17.abrupt("return", result);

              case 5:
                return _context17.abrupt("return", null);

              case 6:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function _generateKey() {
        return _generateKey2.apply(this, arguments);
      }

      return _generateKey;
    }()
  }, {
    key: "_encrypt",
    value: function () {
      var _encrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee18(data) {
        var key, result;
        return _regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                key = this._key;

                if (!(this._cryptoLib && key)) {
                  _context18.next = 6;
                  break;
                }

                _context18.next = 4;
                return this._cryptoLib.encrypt(data, key);

              case 4:
                result = _context18.sent;
                return _context18.abrupt("return", result);

              case 6:
                return _context18.abrupt("return", null);

              case 7:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function _encrypt(_x22) {
        return _encrypt2.apply(this, arguments);
      }

      return _encrypt;
    }()
  }, {
    key: "_decrypt",
    value: function () {
      var _decrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee19(payload) {
        var key, result;
        return _regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                key = this._key;

                if (!(this._cryptoLib && key)) {
                  _context19.next = 6;
                  break;
                }

                _context19.next = 4;
                return this._cryptoLib.decrypt(payload, key);

              case 4:
                result = _context19.sent;
                return _context19.abrupt("return", result);

              case 6:
                return _context19.abrupt("return", null);

              case 7:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function _decrypt(_x23) {
        return _decrypt2.apply(this, arguments);
      }

      return _decrypt;
    }()
  }, {
    key: "_getStorageSession",
    value: function _getStorageSession() {
      var result = null;

      if (this._sessionStorage) {
        result = this._sessionStorage.getSession();
      }

      return result;
    }
  }, {
    key: "_setStorageSession",
    value: function _setStorageSession() {
      if (this._sessionStorage) {
        this._sessionStorage.setSession(this.session);
      }
    }
  }, {
    key: "_removeStorageSession",
    value: function _removeStorageSession() {
      if (this._sessionStorage) {
        this._sessionStorage.removeSession();
      }
    }
  }, {
    key: "_manageStorageSession",
    value: function _manageStorageSession() {
      if (this._connected) {
        this._setStorageSession();
      } else {
        this._removeStorageSession();
      }
    }
  }, {
    key: "_registerPushServer",
    value: function _registerPushServer(pushServerOpts) {
      if (!pushServerOpts.url || typeof pushServerOpts.url !== "string") {
        throw Error("Invalid or missing pushServerOpts.url parameter value");
      }

      if (!pushServerOpts.type || typeof pushServerOpts.type !== "string") {
        throw Error("Invalid or missing pushServerOpts.type parameter value");
      }

      if (!pushServerOpts.token || typeof pushServerOpts.token !== "string") {
        throw Error("Invalid or missing pushServerOpts.token parameter value");
      }

      var pushSubscription = {
        bridge: this.bridge,
        topic: this.clientId,
        type: pushServerOpts.type,
        token: pushServerOpts.token,
        peerName: "",
        language: pushServerOpts.language || ""
      };
      this.on("connect", /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee20(error, payload) {
          var peerName, response, json;
          return _regeneratorRuntime.wrap(function _callee20$(_context20) {
            while (1) {
              switch (_context20.prev = _context20.next) {
                case 0:
                  if (!error) {
                    _context20.next = 2;
                    break;
                  }

                  throw error;

                case 2:
                  if (pushServerOpts.peerMeta) {
                    peerName = payload.params[0].peerMeta.name;
                    pushSubscription.peerName = peerName;
                  }

                  _context20.prev = 3;
                  _context20.next = 6;
                  return fetch("".concat(pushServerOpts.url, "/new"), {
                    method: "POST",
                    headers: {
                      Accept: "application/json",
                      "Content-Type": "application/json"
                    },
                    body: JSON.stringify(pushSubscription)
                  });

                case 6:
                  response = _context20.sent;
                  _context20.next = 9;
                  return response.json();

                case 9:
                  json = _context20.sent;

                  if (json.success) {
                    _context20.next = 12;
                    break;
                  }

                  throw Error("Failed to register in Push Server");

                case 12:
                  _context20.next = 17;
                  break;

                case 14:
                  _context20.prev = 14;
                  _context20.t0 = _context20["catch"](3);
                  throw Error("Failed to register in Push Server");

                case 17:
                case "end":
                  return _context20.stop();
              }
            }
          }, _callee20, null, [[3, 14]]);
        }));

        return function (_x24, _x25) {
          return _ref2.apply(this, arguments);
        };
      }());
    }
  }]);

  return Connector;
}();

export default Connector;